<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="逆向工程核心原理-32"><meta name="keywords" content="逆向工程核心原理"><meta name="author" content="LamのCrow"><meta name="copyright" content="LamのCrow"><title>逆向工程核心原理-32 | LamのCrow</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC32%E7%AB%A0-%E8%AE%A1%E7%AE%97%E5%99%A8%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97"><span class="toc-number">1.</span> <span class="toc-text">逆向工程核心原理-第32章-计算器显示中文数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-1-%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">32.1    技术图表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-2-%E9%80%89%E5%AE%9A%E7%9B%AE%E6%A0%87API"><span class="toc-number">3.</span> <span class="toc-text">32.2    选定目标API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-3-IAT%E9%92%A9%E5%8F%96%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">32.3    IAT钩取工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#32-3-0-%E6%B3%A8%E6%84%8F"><span class="toc-number">4.1.</span> <span class="toc-text">32.3.0    注意</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-4-%E7%BB%83%E4%B9%A0%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">32.4    练习示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-5-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">32.5    源代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#32-5-1-DllMain"><span class="toc-number">6.1.</span> <span class="toc-text">32.5.1    DllMain()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-5-2-MySetWindowTextW"><span class="toc-number">6.2.</span> <span class="toc-text">32.5.2    MySetWindowTextW()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-5-2-hook-iat-%E6%8C%82%E9%92%A9%E5%92%8C%E8%84%B1%E9%92%A9%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">32.5.2    hook_iat()(挂钩和脱钩函数)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-6-%E8%B0%83%E8%AF%95%E8%A2%AB%E6%B3%A8%E5%85%A5%E7%9A%84DLL%E6%96%87%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">32.6    调试被注入的DLL文件</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s4.ax1x.com/2021/12/07/oyWTJA.jpg"></div><div class="author-info__name text-center">LamのCrow</div><div class="author-info__description text-center">欢迎交流!!!</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">35</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://space.bilibili.com/202089320">MyBIlibili</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://sma11cc.github.io/">smallcc</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">LamのCrow</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">逆向工程核心原理-32</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-19</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="逆向工程核心原理-第32章-计算器显示中文数字"><a href="#逆向工程核心原理-第32章-计算器显示中文数字" class="headerlink" title="逆向工程核心原理-第32章-计算器显示中文数字"></a>逆向工程核心原理-第32章-计算器显示中文数字</h1><span id="more"></span>

<p>通过DLL注入钩取API,  是将DLL注入目标进程后,  修改IAT更改进程中调用的特定API的功能</p>
<h1 id="32-1-技术图表"><a href="#32-1-技术图表" class="headerlink" title="32.1    技术图表"></a>32.1    技术图表</h1><p>以下注入DLL实现API钩取的所需要的技术,  画下划线就是使用的技术</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled.png" alt="Untitled"></p>
<h1 id="32-2-选定目标API"><a href="#32-2-选定目标API" class="headerlink" title="32.2    选定目标API"></a>32.2    选定目标API</h1><p>再进行钩取API之前,  首先我们要确定钩取哪个API</p>
<p>我们本次实例的目标是”计算器显示的文本”,  能实现这个功能的API:  SetWindowTextW(),  SetDlgItemTextW().  而SetDlgItemTextW()中又调用了SetWindowTextW().  所以我们可以锁定目标API—SetWindowTextW()</p>
<p>我们看看SetWindowTextW()的函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetWindowTextW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		HWND hWnd,         <span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">		LPCTSTR lpString   <span class="comment">//窗口要输出的字符串指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们想要实现将阿拉伯数字改为中文数字</p>
<p>我们首先使用OD来验证上面的猜想:  SetWindowTextW()就是我们要修改的API</p>
<p>首先用OD打开calc</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%201.png" alt="Untitled"></p>
<p>然后查看所有模块引用,  并找到SetWindowTextW()(我的OD加载不出引入函数的符号,  所以换了x32dbg来调试)</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%202.png" alt="Untitled"></p>
<p>在这两个地方设下断点.随后我们F9运行,  先进入了EntryPoint,  然后再F9就停在了SetWindowTextW()前</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%203.png" alt="Untitled"></p>
<p>观察上图的栈区,  可以看到两个参数逆序压入栈中,  我们可以看到第二个参数是”0.”,  这正是计算器程序一开始要输出的内容.  我们再一次F9,  就可以看见计算器的窗口弹出,  并输出了”0.”</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%204.png" alt="Untitled"></p>
<p> 现在我们输入7</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%205.png" alt="Untitled"></p>
<p>可以看到第二个参数也变成了L”7.”,  我们尝试把7改成”七”,  首先先转到我们的数据缓冲区中</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%206.png" alt="Untitled"></p>
<p>将0x37改为4e03,  由于小端,  所以在内存中是034e</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%207.png" alt="Untitled"></p>
<p>我们再次运行</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%208.png" alt="Untitled"></p>
<p>可以看到输出变成了”七.”.</p>
<p>由此我们可以确定我们需要钩取的API就是SetWindowTextW()</p>
<p>接下来就正式开始钩取IAT</p>
<h1 id="32-3-IAT钩取工作原理"><a href="#32-3-IAT钩取工作原理" class="headerlink" title="32.3    IAT钩取工作原理"></a>32.3    IAT钩取工作原理</h1><p>进程的IAT中保存着程序中调用API的地址</p>
<p>IAT钩取通过修改IAT中保存的API地址来钩取某个API</p>
<p>下面是正常使用IAT调用函数的流程</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%209.png" alt="Untitled"></p>
<ul>
<li>首先1002628处使用了CALL指令调用01001110处的值</li>
<li>而01001110处的值为我们API的地址77D0960E</li>
<li>实际上调用的是77D0960E</li>
</ul>
<p>下面是IAT被钩取后的流程</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2010.png" alt="Untitled"></p>
<ul>
<li>01002628地址处调用了[01001110]跟上面是一样的</li>
<li>但是[01001110]处存储的实际调用地址被修改成了10001000</li>
<li>于是控制流转移到了10001000,  这里就是我们的钩取函数MySetWindowTextW()</li>
<li>执行完其语句后再结尾调用了[1000B6B8]</li>
<li>而1000B6B8处存储的是实际调用地址77D0960E,  这个地址就是我们原来的SetWindowTextW()</li>
<li>随后调用了SetWindowTextW()</li>
<li>返回到原来的位置</li>
</ul>
<p>整个流程就是把原本调用SetWindowTextW()的位置替换成了MySetWindowTextW(),  随后再MySetWindowTextW()中调用了SetWindowTextW().</p>
<p>核心思想是:  在<strong>保持运行代码不变</strong>的前提下,  将<strong>IAT</strong>中保存的API起始地址<strong>变为我们的钩取函数</strong>的起始地址.</p>
<h2 id="32-3-0-注意"><a href="#32-3-0-注意" class="headerlink" title="32.3.0    注意"></a>32.3.0    注意</h2><p>我想在这里提一下DLL注入跟IAT钩取之间的关系,  DLL是IAT钩取实现的基础,  而IAT钩取是API钩取的实现思路之一(前面的调试钩取也是思路之一).  千万不要把DLL注入跟这些概念搞混了.  后面还会提到调试钩取API跟钩取IAT之间的区别.</p>
<h1 id="32-4-练习示例"><a href="#32-4-练习示例" class="headerlink" title="32.4    练习示例"></a>32.4    练习示例</h1><p>我们首先打开calc</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2011.png" alt="Untitled"></p>
<p>查找其PID</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2012.png" alt="Untitled"></p>
<p>随后使用管理员身份打开终端</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2013.png" alt="Untitled"></p>
<p>其中第二个参数表示Inject(注入)</p>
<p>成功注入时,  我们回到calc中可以看到输出不一样了</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2014.png" alt="Untitled"></p>
<p>然后脱钩</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2015.png" alt="Untitled"></p>
<p>第二参数e表示end结束</p>
<p>随后键入一个值</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2016.png" alt="Untitled"></p>
<p>可以看到字符恢复了</p>
<h1 id="32-5-源代码分析"><a href="#32-5-源代码分析" class="headerlink" title="32.5    源代码分析"></a>32.5    源代码分析</h1><p>InjectDll.cpp跟前面的DLL注入的InjectDll.cpp时类似的:  通过查找PID获取进程句柄,  同时获取LoadLibrary()API,  然后通过像目标进程(我们已有进程句柄)创建远程线程调用LoadLibrary()API来加载我们像注入的DLL.</p>
<h2 id="32-5-1-DllMain"><a href="#32-5-1-DllMain" class="headerlink" title="32.5.1    DllMain()"></a>32.5.1    DllMain()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">LPVOID g_pOrgFunc;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="comment">//保存原始API地址, 并保存在全局变量中, 便于后面挂钩和脱钩</span></span><br><span class="line">        g_pOrgFunc = GetProcAddress(GetModuleHandle(<span class="string">L&quot;user32.dll&quot;</span>), <span class="string">&quot;SetWindowTextW&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//挂钩</span></span><br><span class="line">        hook_iat(<span class="string">&quot;user32.dll&quot;</span>, g_pOrgFunc, (PROC)MySetWindowTextW);<span class="comment">//MySetWindowTextW因为已经存在在DLL中, 所以可以直接使用函数名代表其函数地址</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="comment">//脱钩</span></span><br><span class="line">        hook_iat(<span class="string">&quot;user32.dll&quot;</span>, (PROC)MySetWindowTextW, g_pOrgFunc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程:</p>
<ul>
<li>首先注入时使用标签DLL_PROCESS_ATTACH:  全局变量保存SetWindowTextW()的API地址,  并挂钩,  即替换IAT</li>
<li>当结束钩取时使用标签DLL_PROCESS_DETACH:  脱钩,  即将IAT中的内容复原</li>
</ul>
<p>这里还是跟上一章一样,  要记住全局变量的内容,  后面还会用到.</p>
<h2 id="32-5-2-MySetWindowTextW"><a href="#32-5-2-MySetWindowTextW" class="headerlink" title="32.5.2    MySetWindowTextW()"></a>32.5.2    MySetWindowTextW()</h2><p>MySetWindowTextW()为钩取函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时g_pOrgFunc = SetWindowTextW()函数的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* PFSETWINDOWTEXTW)</span><span class="params">(HWND hWnd, LPWSTR lpString)</span></span>;<span class="comment">//定义函数指针, 便于后面调用SeiWindowTextW</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">MySetWindowTextW</span><span class="params">(HWND hWnd, LPWSTR lpString)</span><span class="comment">//这个被替换后的函数正常接收参数, 第二参数就是输出字符串的指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">wchar_t</span>* pNum = <span class="string">L&quot;零一二三四五六七八九&quot;</span>;<span class="comment">//定义需要替换的字符, 类型为宽字符</span></span><br><span class="line">    <span class="keyword">wchar_t</span> temp[<span class="number">2</span>] = &#123; <span class="number">0</span>, &#125;;<span class="comment">//为什么要使用数组: 因为后面_wtoi()是将&lt;字符串&gt;转换为&lt;整数&gt;, </span></span><br><span class="line">                             <span class="comment">//单个字符无法转换, 所以需要利用数组在结尾添加上&#x27;\0&#x27;组成字符串</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, nLen = <span class="number">0</span>, nIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nLen = wcslen(lpString);<span class="comment">//获取输出缓冲区的字符串长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nLen; i++) &#123;<span class="comment">//开始转换字符串</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">L&#x27;0&#x27;</span> &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= <span class="string">L&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[<span class="number">0</span>] = lpString[i];</span><br><span class="line">            nIndex = _wtoi(temp);<span class="comment">//将字符转换成整数,并作为下标找到对应的替换字符</span></span><br><span class="line">            lpString[i] = pNum[nIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//g_pOrgFunc存储的是SetWindowTextW函数指针</span></span><br><span class="line">    <span class="comment">//修改完缓冲区数据以后, 调用原来的SetWindowTextW()</span></span><br><span class="line">    <span class="keyword">return</span> ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此我们在回头看看整个的思路</p>
<ul>
<li>首先是InjectDll.exe负责注入DLL到目标进程中,  用的方法应该是远程创建线程</li>
<li>于是我们来到了DllMain中,  注意此时我们已经进入了目标进程的内存中,  可以对其数据进行修改</li>
<li>在DllMian中我们实现了挂钩—将目标进程内存中的IAT进行修改,  使其跳转到DLL中的数据处理函数(该函数也随着DLL的注入而进入了目标进程的内存中,  所以可以正常调用)</li>
<li>在钩取函数中修改数据,  然后再调用原来的函数,  就像是加了一个中间加工的过程.</li>
<li>然后在DLL卸载的时候,  我们进行了脱钩—将目标进程内存中的IAT复原</li>
</ul>
<p>我们已经解决了DllMain和数据处理函数,  最关键的挂钩和脱钩操作将在下面的进行分析,  之所以在这里提到这个是因为在书中对源代码的分析不是按照逻辑顺序进行的,  而是从简到难,  所以不梳理以下整个流程会有些混乱.</p>
<h2 id="32-5-2-hook-iat-挂钩和脱钩函数"><a href="#32-5-2-hook-iat-挂钩和脱钩函数" class="headerlink" title="32.5.2    hook_iat()(挂钩和脱钩函数)"></a>32.5.2    hook_iat()(挂钩和脱钩函数)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    &quot;user32.dll&quot;的字符串指针  需要替换的函数指针  替换的函数指针</span></span><br><span class="line"><span class="function">BOOL <span class="title">hook_iat</span><span class="params">(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hMod;</span><br><span class="line">    LPCSTR szLibName;</span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImportDesc;<span class="comment">//导入描述符IID结构体指针</span></span><br><span class="line">    PIMAGE_THUNK_DATA pThunk;<span class="comment">//IID结构体中的一个成员, 用于之处IAT的起始地址</span></span><br><span class="line">    DWORD dwOldProtect, dwRVA;<span class="comment">//dwOldProtect存储之前的内存段保护属性, dwRVA存储RVA</span></span><br><span class="line">    PBYTE pAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前进程句柄</span></span><br><span class="line">    hMod = GetModuleHandle(<span class="literal">NULL</span>);<span class="comment">//参数为NULL是, 返回当前调用该函数的进程的句柄, 也就是文件的基地址(开头)</span></span><br><span class="line">    <span class="comment">//通过进程句柄获得进程基址</span></span><br><span class="line">    pAddr = (PBYTE)hMod;<span class="comment">//但是hMod类型为HMODULE, 要作为位置指针的话需要强制类型转换为字节指针</span></span><br><span class="line">                        <span class="comment">//此时pAddr就是我们的进程当前起始位置的虚拟地址VA</span></span><br><span class="line">    <span class="comment">//获取NT头地址</span></span><br><span class="line">    pAddr += *((DWORD*)&amp;pAddr[<span class="number">0x3C</span>]);<span class="comment">//首先右边的整个部分就是&lt;进程偏移为0x3C上大小为4字节的内容&gt;, 而根据前面我们PE所学的部分, 这个内容是下一个节区头的偏移</span></span><br><span class="line">                                     <span class="comment">//所以pAddr += 下一个节区头的偏移, 此时pAddr指向的是NT头开头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取导入表RVA</span></span><br><span class="line">    dwRVA = *((DWORD*)&amp;pAddr[<span class="number">0x80</span>]);<span class="comment">//跟上面类似, 此时pAddr指向的是NT头起始地址, 在此基础上偏移0x80所指向的内容是IMPORT TABLE(导入表)的RVA</span></span><br><span class="line">                                    <span class="comment">//所以dwRVA所代表的是导入表的RVA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先pImportDesc的类型是IID结构体指针, 而前面dwRVA所指向的地址就是导入表, 所以类型转换后就是第一个IID结构体指针</span></span><br><span class="line">    pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod + dwRVA);<span class="comment">//这里加上hMod是因为dwRVA是导入表的RVA, 要转换成准确的虚拟地址要加上Base基址, 而示例中的基址就是hMod</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们要知道结尾为NULL结构体, 所以这个条件的意思就是要遍历导入表的每个IID</span></span><br><span class="line">    <span class="keyword">for</span> (; pImportDesc-&gt;Name; pImportDesc++); &#123;<span class="comment">//IID指针++就是指向下一个结构体</span></span><br><span class="line">        szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);<span class="comment">//可能会觉得奇怪为什么pImportDesc前面已经转换为准确的VA了, 为什么还是要加上hMod基址</span></span><br><span class="line">                                                              <span class="comment">//因为Name成员表示的是模块名称字符串的RVA, 所以还是得加上hMod才能得到准确的VA</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!stricmp(szLibName, szDllName)) &#123;<span class="comment">//szDllName即是我们传入hook_iat的参数, 是我们要查找的模块名称</span></span><br><span class="line">            <span class="comment">//当检验发现查到对应的&quot;user32.dll&quot;时, 获取描述user32.dll的pThunk, pThunk指向的时IAT的指针, 注意要类型转换, 因为转换为ITD的指针才能获取并操控ITD结构体</span></span><br><span class="line">            pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + pImportDesc-&gt;FirstThunk);<span class="comment">//成员FirstThunk所记录的IAT地址也是RVA形式, 所以要加上hMod基址</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历IAT, 成员u1联合体Function为函数指针</span></span><br><span class="line">            <span class="keyword">for</span> (; pThunk-&gt;u1.Function; pThunk++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果遍历到的函数指针就是我们需要替换的函数起始地址的话, 说明这就是我们需要修改的IAT</span></span><br><span class="line">                <span class="keyword">if</span> (pThunk-&gt;u1.Function == (DWORD)pfnOrg) &#123;</span><br><span class="line">                    <span class="comment">//将该IAT地址区域保护属性修改为可读可写, 并将原来的保护属性保存在dwOldProtect中</span></span><br><span class="line">                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//修改IAT</span></span><br><span class="line">                    pThunk-&gt;u1.Function = (DWORD)pfnNew;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//恢复内存属性</span></span><br><span class="line">                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, <span class="number">4</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果成功修改了IAT, 则返回TURE</span></span><br><span class="line">                    <span class="keyword">return</span> TRUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有找到对应的IAT, 则返回FLASE</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="32-6-调试被注入的DLL文件"><a href="#32-6-调试被注入的DLL文件" class="headerlink" title="32.6    调试被注入的DLL文件"></a>32.6    调试被注入的DLL文件</h1><p>首先打开calc(计算器),  并使用process explorer查看其PID</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2017.png" alt="Untitled"></p>
<p>接下来使用OD(这里换成了x32dbg)附加到calc上</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2018.png" alt="Untitled"></p>
<p>F9使其处于running状态</p>
<p>并设置调试选项</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2019.png" alt="Untitled"></p>
<p>随后开始通过注入DLL来修改IAT从而实现API钩取</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2020.png" alt="Untitled"></p>
<p>调试器会停在hookiat.dll的入口点随后即可开始调试</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2021.png" alt="Untitled"></p>
<p>这里明显不是DllMian,  所以我们需要先找到DllMian的位置,  而这里最简单的方式就是字符串查找</p>
<p>我们已经知道DllMian中在调用GetProcAddress函数时,  使用了两个字符串指针”user32.dll”和”SetWindowTextW”,  所以可以通过这个来找到我们的DllMian</p>
<p><img src="/2022/04/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20e28be/Untitled%2022.png" alt="Untitled"></p>
<p>确定了这里是DllMian后我们在该函数的开头下下断点并F9</p>
<p>即可开始调试DLL</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LamのCrow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/19/逆向工程核心原理-第 e28be/">http://example.com/2022/04/19/逆向工程核心原理-第 e28be/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">LamのCrow</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">逆向工程核心原理</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/"><i class="fa fa-chevron-left">  </i><span>逆向工程核心原理-33</span></a></div><div class="next-post pull-right"><a href="/2022/04/18/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%204eaea/"><span>逆向工程核心原理-30</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By LamのCrow</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">追求幸福</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>