<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="逆向工程核心原理-27"><meta name="keywords" content="逆向工程核心原理"><meta name="author" content="LamのCrow"><meta name="copyright" content="LamのCrow"><title>逆向工程核心原理-27 | LamのCrow</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC27%E7%AB%A0-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">逆向工程核心原理-第27章-代码注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-1-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5"><span class="toc-number">2.</span> <span class="toc-text">27.1    代码注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-2-DLL%E6%B3%A8%E5%85%A5%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5"><span class="toc-number">3.</span> <span class="toc-text">27.2    DLL注入与代码注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DLL%E6%B3%A8%E5%85%A5"><span class="toc-number">3.1.</span> <span class="toc-text">DLL注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5"><span class="toc-number">3.2.</span> <span class="toc-text">代码注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.3.</span> <span class="toc-text">使用代码注入的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E5%B0%91"><span class="toc-number">3.3.1.</span> <span class="toc-text">1.  占用内存少</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9A%BE%E4%BB%A5%E6%9F%A5%E6%89%BE%E7%97%95%E8%BF%B9"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.  难以查找痕迹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B6%E4%BB%96"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.  其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-3-%E7%BB%83%E4%B9%A0%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">27.3    练习示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#27-3-1-%E8%BF%90%E8%A1%8Cnotepad-exe"><span class="toc-number">4.1.</span> <span class="toc-text">27.3.1    运行notepad.exe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-3-2-%E8%BF%90%E8%A1%8CCodeInjection-exe"><span class="toc-number">4.2.</span> <span class="toc-text">27.3.2    运行CodeInjection.exe</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-4-CodeInjection-cpp"><span class="toc-number">5.</span> <span class="toc-text">7.4    CodeInjection.cpp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#27-4-1-CodeInjection-exe%E7%9A%84main-%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">27.4.1    CodeInjection.exe的main()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-4-2-ThreadProc-%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">27.4.2    ThreadProc()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-4-3-InjectCode-%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">27.4.3    InjectCode()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3"><span class="toc-number">5.3.1.</span> <span class="toc-text">分析代码注入一些理解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-5-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A0"><span class="toc-number">6.</span> <span class="toc-text">27.5    代码注入调试练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#27-5-1-%E8%B0%83%E8%AF%95notepad-exe"><span class="toc-number">6.1.</span> <span class="toc-text">27.5.1    调试notepad.exe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-5-3-%E8%AE%BE%E7%BD%AEOllyDbg%E9%80%89%E9%A1%B9"><span class="toc-number">6.2.</span> <span class="toc-text">27.5.3    设置OllyDbg选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-5-3-%E8%BF%90%E8%A1%8CCodeInjection-exe"><span class="toc-number">6.3.</span> <span class="toc-text">27.5.3    运行CodeInjection.exe</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s4.ax1x.com/2021/12/07/oyWTJA.jpg"></div><div class="author-info__name text-center">LamのCrow</div><div class="author-info__description text-center">欢迎交流!!!</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">30</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://space.bilibili.com/202089320">MyBIlibili</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://sma11cc.github.io/">smallcc</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">LamのCrow</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">逆向工程核心原理-27</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-09</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="逆向工程核心原理-第27章-代码注入"><a href="#逆向工程核心原理-第27章-代码注入" class="headerlink" title="逆向工程核心原理-第27章-代码注入"></a>逆向工程核心原理-第27章-代码注入</h1><span id="more"></span>

<p>参考了SYJ学长的博客:<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-267065.htm">https://bbs.pediy.com/thread-267065.htm</a></p>
<h1 id="27-1-代码注入"><a href="#27-1-代码注入" class="headerlink" title="27.1    代码注入"></a>27.1    代码注入</h1><p>代码注入是一种向目标进程插入独立运行代码并是指运行的技术,  它一般调用CreateRemoteThread()API以远程线程形式运行插入的代码,  所以也被称为线程注入.</p>
<p>下图是代码注入技术的实现原理</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled.png" alt="Untitled"></p>
<p>首先向target.exe插入代码与数据,  此过程中:</p>
<ul>
<li>代码以<strong>线程过程</strong>(Thread Procedure)形式插入</li>
<li>数据以<strong>线程参数</strong>的形式插入</li>
</ul>
<p>也就是说,  代码与数据是<strong>分别注入</strong>的.</p>
<h1 id="27-2-DLL注入与代码注入"><a href="#27-2-DLL注入与代码注入" class="headerlink" title="27.2    DLL注入与代码注入"></a>27.2    DLL注入与代码注入</h1><p>请看下面的简单代码,  其作用是弹出Windows消息框</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;www.reversecore.com&quot;</span>, <span class="string">&quot;ReverseCore&quot;</span>, MB_OK)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里讲一下MessageBoxA函数</span><br><span class="line"></span><br><span class="line">作用: 弹出Windows消息框</span><br><span class="line"></span><br><span class="line">函数原型:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] HWND   hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           UINT   uType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">参数解析:</span><br><span class="line">hWnd: 该消息框的所有者窗口的句柄, 即该窗口的父窗口句柄, 如果为<span class="literal">NULL</span>,  则该窗口没有所有者窗口</span><br><span class="line"></span><br><span class="line">lpText: 要显示的文本字符串指针</span><br><span class="line">LPCSTR类型L代表<span class="keyword">long</span>, P代表pointer, C代表<span class="keyword">const</span>, STR代表<span class="built_in">string</span>,  前面也记过笔记但是又忘记了</span><br><span class="line"></span><br><span class="line">lpCaption: 消息框的标题字符串指针</span><br><span class="line"></span><br><span class="line">uType: 对话框的内容和行为, 比如有无按钮之类</span><br><span class="line">以下为该参数可取的值</span><br><span class="line">MB_ABORTRETRYIGNORE    包含三个按钮Abort, Retry和Ignore</span><br><span class="line">MB_CANCELTRYCONTINUE   包含三个按钮取消, 重试, 继续</span><br><span class="line">MB_HELP                消息框添加帮助按钮</span><br><span class="line">MB_OK                  包含一个OK按钮</span><br><span class="line">MB_OKCANCEL            包含两个按钮  OK和Cancel</span><br><span class="line">MB_RETRYCANCEL         包含两个按钮  重试和取消</span><br><span class="line">MB_YESNO               包含两个按钮  Yes和No</span><br><span class="line">MB_YESNOCANCEL         包含三个按钮  Yes, No和Cancel</span><br></pre></td></tr></table></figure>

<h2 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h2><p>如果是DLL注入技术,  则会将上述代码放入某个DLL文件,  再通过将DLL注入到目标进程后调用DllMain函数然后再在其中调用这段代码</p>
<p>书中没给DLL注入程序,  所以就直接截书上的图了</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%201.png" alt="Untitled"></p>
<p>我们可以看到在DLL注入完成后调用MessageBoxA的整个调用过程</p>
<p>在10001002地址处有一条<code>PUSH    10009290</code>指令,  紧接着是<code>PUSH    1000929C</code>指令.</p>
<p>在OD的Dump窗口中查看地址<code>10009290</code>与<code>1000929C</code>,  如下图所示</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%202.png" alt="Untitled"></p>
<p>可以看到上面的<code>10009290</code>与<code>1000929C</code>, 在这里都有对应的数据(两个字符串),  所需要的数据都保存在导入的DLL当中</p>
<p>我们再回过头去看看调用MessageBoxA的汇编语句<code>CALL    DWORD    PTR    DS : [100080F0]</code>指令,  该指令调用的是user32.dll中的MessageBoxA()函数,  转到<code>100080F0</code>处查看</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%203.png" alt="Untitled"></p>
<p>可以看到该区域为DLL的IAT(导入地址表)上面还有导入的kernel32.dll的LCMapStringW函数和ntdll.dll的RtlSizeHeap函数.  可以看到MessageBoxA的地址数据也存放在DLL当中</p>
<p>我们从上面对DLL注入的分析可以看到,  DLL注入的代码(整个调用MessageBoxA过程,  不是MessageBoxA的库函数)与数据都存放在DLL当中,  当DLL被插入到进程内存中时,  代码和数据都进入到了目标进程的内存空间,  所以代码能够正常运行</p>
<h2 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h2><p>而代码注入则不同,  它不像DLL注入能把代码和数据打包在一起,  如果想要注入的代码能够正常运行,  还需要想办法把代码所需要使用的数据也一同注入进去,  比如上面调用MessageBoxA()所需要使用的两个字符串参数数据,  没有它们MessageBoxA()将无法成功调用</p>
<h2 id="使用代码注入的原因"><a href="#使用代码注入的原因" class="headerlink" title="使用代码注入的原因"></a>使用代码注入的原因</h2><p>使用代码注入实现的功能跟DLL注入类似,  却要比DLL注入要麻烦,  那为什么要使用代码注入呢</p>
<h3 id="1-占用内存少"><a href="#1-占用内存少" class="headerlink" title="1.  占用内存少"></a>1.  占用内存少</h3><p>要注入的代码与数据较少,  就不需要将它们做成DLL的形式再注入. 此时直接采用代码注入的方式同样能获得与DLL注入相同的效果,  且占用的内存会更少</p>
<h3 id="2-难以查找痕迹"><a href="#2-难以查找痕迹" class="headerlink" title="2.  难以查找痕迹"></a>2.  难以查找痕迹</h3><p>采用DLL注入的方式会再目标进程的内存中留下相关痕迹,  很容易让人判断出目标进程是否被执行过注入操作,  但采用代码注入方式几乎不会留下任何痕迹,  恶意代码中大量使用代码注入技术</p>
<h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.  其他"></a>3.  其他</h3><p>不需要另外的DLL文件,  只要有代码注入程序即可.</p>
<p>总结:  DLL注入技术主要用在代码量大且复杂的时候,  而代码注入技术则适用于代码量小且简单的时候(想想,  如果要用到100个数据是使用代码注入,  数据的注入会非常麻烦)</p>
<h1 id="27-3-练习示例"><a href="#27-3-练习示例" class="headerlink" title="27.3    练习示例"></a>27.3    练习示例</h1><p>示例为CodeInjection.exe用于代码注入,  它向notepad.exe进程注入简单的代码,  注入后会弹出消息框</p>
<h2 id="27-3-1-运行notepad-exe"><a href="#27-3-1-运行notepad-exe" class="headerlink" title="27.3.1    运行notepad.exe"></a>27.3.1    运行notepad.exe</h2><p>首先运行notepad.exe  然后使用ProcessExplorer查看notepad.exe进程的PID</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%204.png" alt="Untitled"></p>
<p>可以看到notepad的PID为29592</p>
<h2 id="27-3-2-运行CodeInjection-exe"><a href="#27-3-2-运行CodeInjection-exe" class="headerlink" title="27.3.2    运行CodeInjection.exe"></a>27.3.2    运行CodeInjection.exe</h2><p>在命令行窗口中输入命令与参数,  注意要用管理员身份打开,  否则会The token does not have the specified privilege.报错</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%205.png" alt="Untitled"></p>
<p>运行成功后发现notepad.exe弹出了一个窗口</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%206.png" alt="Untitled"></p>
<h1 id="7-4-CodeInjection-cpp"><a href="#7-4-CodeInjection-cpp" class="headerlink" title="7.4    CodeInjection.cpp"></a>7.4    CodeInjection.cpp</h1><p>下面的代码略去了异常处理部分</p>
<h2 id="27-4-1-CodeInjection-exe的main-函数"><a href="#27-4-1-CodeInjection-exe的main-函数" class="headerlink" title="27.4.1    CodeInjection.exe的main()函数"></a>27.4.1    CodeInjection.exe的main()函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><span class="comment">//接收的参数数目以及参数本身,  在这里我们有两个在命令行输入的参数</span></span></span><br><span class="line"><span class="function"></span>&#123;																<span class="comment">//argv[0] = &quot;CodeInjection.exe&quot;,argv[1] = &quot;29592&quot;</span></span><br><span class="line">		DWORD dwPID    = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( argc != <span class="number">2</span> )<span class="comment">//检查我们输入的参数个数是否正确</span></span><br><span class="line">		&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\n  USAGE   : %s pid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//代码注入</span></span><br><span class="line">		dwPID = (DWORD)atol(argv[<span class="number">1</span>]);<span class="comment">//我们输入的PID原本的形式是字符串, 使用atol转换成了整数</span></span><br><span class="line">		InjectCode(dwPID);<span class="comment">//调用注入代码函数, 参数是代码注入的目标进程的PID</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-4-2-ThreadProc-函数"><a href="#27-4-2-ThreadProc-函数" class="headerlink" title="27.4.2    ThreadProc()函数"></a>27.4.2    ThreadProc()函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义用于线程参数传递的线程参数结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">THREAD_PARAM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">		FARPROC pFunc[<span class="number">2</span>];       <span class="comment">//FARPROC类型为指向WINAPI的**函数指针**,</span></span><br><span class="line">														<span class="comment">//用来存LoadLibraryA(), GetProcAddress()两个函数的指针 </span></span><br><span class="line">		<span class="keyword">char</span>    szBuf[<span class="number">4</span>][<span class="number">128</span>];  <span class="comment">/*存放参数</span></span><br><span class="line"><span class="comment">															&quot;user32.dll&quot;, &quot;MessageBoxA&quot;, </span></span><br><span class="line"><span class="comment">															&quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;*/</span></span><br><span class="line">&#125; THREAD_PARAM, *PTHREAD_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了LoadLibraryA的函数指针, 定义这个类型的作用是到时候是使用函数指针来调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI *PFLOADLIBRARYA)</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR lpLibFileName<span class="comment">//HMODULE为返回值，调用约定为WINAPI，指针名叫PFLOADLIBRARYA，参数为字符串指针lpLibFileName</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;<span class="comment">//LPCSTR在上面分析过, 是一个字符串指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同理GetProcAddress()的函数指针,  方便后面调用GetProcAddress()函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI *PFGETPROCADDRESS)</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HMODULE hModule,<span class="comment">//模块句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR lpProcName<span class="comment">//查找的函数名字符串指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MessageBoxA的函数指针,  关于MessageBoxA的解析看最上面的代码块</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *PFMESSAGEBOXA)</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">UINT uType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span>     <span class="comment">//线程过程，用来存放我们的注入代码</span></span></span><br><span class="line"><span class="function">																					 <span class="comment">//传入的是参数结构体的指针,这个指针是无类型, 后面会转换类型并赋值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PTHREAD_PARAM   pParam = (PTHREAD_PARAM)lParam;   <span class="comment">//将传入的指针强制类型转换为我们定义的线程参数结构体类型的指针，其实指针本质都是相同的，只是语言的语法要求</span></span><br><span class="line">    HMODULE         hMod = <span class="literal">NULL</span>;                                              <span class="comment">//定义一个hMod来存放模块句柄</span></span><br><span class="line">    FARPROC         pFunc = <span class="literal">NULL</span>;                                                  <span class="comment">//定义一个FARPROC类型的变量来存放GetProcAddress的返回值</span></span><br><span class="line"> </span><br><span class="line">    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[<span class="number">0</span>])(pParam-&gt;szBuf[<span class="number">0</span>]);   <span class="comment">// LoadLibrary(&quot;user32.dll&quot;)</span></span><br><span class="line">																																	 <span class="comment">//((PFLOADLIBRARYA)pParam-&gt;pFunc[0])先强制类型转换了成了LoadLibrary函数类型指针</span></span><br><span class="line">																																	 <span class="comment">//然后使用参数结构体中的LoadLibrary的地址, 调用了LoadLibrary()函数,加载模块</span></span><br><span class="line">    <span class="keyword">if</span> (!hMod)<span class="comment">//返回了user32.dll模块的句柄</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[<span class="number">1</span>])(hMod, pParam-&gt;szBuf[<span class="number">1</span>]);  <span class="comment">// GetProcAddress(hMod, &quot;MessageBoxA&quot;);同理调用了GetProcAddress</span></span><br><span class="line">    </span><br><span class="line">		<span class="keyword">if</span> (!pFunc)<span class="comment">//获得了MessageBoxA的函数指针</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    ((PFMESSAGEBOXA)pFunc)(<span class="literal">NULL</span>, pParam-&gt;szBuf[<span class="number">2</span>], pParam-&gt;szBuf[<span class="number">3</span>], MB_OK);    <span class="comment">// MessageBoxA(NULL, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;, MB_OK);</span></span><br><span class="line">																																								<span class="comment">//使用该指针调用了函数MessageBoxA, 可以看到所用的参数均在参数结构体中</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码实际被注入的部分是ThreadProc()函数,  其中使用了很多的函数指针,  经过整理后会非常简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hMod = LoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">pFunc = GetProcAddress(hMod, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">pFunc(<span class="literal">NULL</span>, <span class="string">&quot;www.reversecore.com&quot;</span>, <span class="string">&quot;ReverseCore&quot;</span>, MB_OK);</span><br></pre></td></tr></table></figure>

<p>上面的代码并不是故意写得那么乱,  而是代码注入的方式所导致的.</p>
<p>重要的是ThreadProc()代码的概念:  代码注入技术的核心内容是注入<strong>可独立运行的</strong>代码,  为此,  需要同时注入代码与数据.</p>
<p>ThreadProc所用的到的数据都是通过lParam参数传递的.</p>
<p>我们看看普通程序                 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;www.reversecore.com&quot;</span>, <span class="string">&quot;ReverseCore&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用调试器调试生成的文件</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%207.png" alt="Untitled"></p>
<p>可以看见,  如果将该段代码<strong>直接</strong>注入,  则代码无法正常运行,  因为代码中引用的地址(<code>10009290</code>, <code>1000929C</code>, <code>100080F0</code>)并不存在于<strong>目标进程</strong>中, 要使代码能够正常运行,  必须向相应地址同时注入相关字符串以及API地址,  并且通过编程方式使上图代码也能够准确引用被注入数据的地址</p>
<p>为了满足这些条件,  ThreadProc函数中使用THREAD_PARAM(线程参数)结构体来接收2个API地址与4个字符串数据.  其中2个API分别是LoadLibraryA与GetProcAddress(),  只要有了这两个API,  就能够调用目标进程加载的库的所有库函数.</p>
<p>大部分用户模式进程都会加载kernel32.dll,  所以直接传递LoadLibraryA()与GetProcAddress()的地址不会有什么问题(因为是固定的).</p>
<p>调试我们CodeInject.exe中的Threadproc</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%208.png" alt="Untitled"></p>
<p>可以看到[EBP + 8]就是我们的参数结构体</p>
<p>重要的数据都是从[EBP + 8]中获取的,  所以这个ThreadProc()函数是可以独立运行的代码</p>
<h2 id="27-4-3-InjectCode-函数"><a href="#27-4-3-InjectCode-函数" class="headerlink" title="27.4.3    InjectCode()函数"></a>27.4.3    InjectCode()函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InjectCode</span><span class="params">(DWORD dwPID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE         hMod = <span class="literal">NULL</span>;<span class="comment">//模块句柄</span></span><br><span class="line">    THREAD_PARAM    param = &#123; <span class="number">0</span>, &#125;;<span class="comment">//参数结构体</span></span><br><span class="line">    HANDLE          hProcess = <span class="literal">NULL</span>;<span class="comment">//进程句柄</span></span><br><span class="line">    HANDLE          hThread = <span class="literal">NULL</span>;<span class="comment">//线程句柄</span></span><br><span class="line">    LPVOID          pRemoteBuf[<span class="number">2</span>] = &#123; <span class="number">0</span>, &#125;; <span class="comment">//void型的长指针，用来指向分配的内存</span></span><br><span class="line">    DWORD           dwSize = <span class="number">0</span>;<span class="comment">//大小</span></span><br><span class="line"> </span><br><span class="line">    hMod = GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>);<span class="comment">//获取kernel32.dll句柄</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//给线程参数结构体赋值, 注意这个参数结构体是CodeInject.exe内存空间中的参数结构体</span></span><br><span class="line">    param.pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">&quot;LoadLibraryA&quot;</span>);  </span><br><span class="line">    param.pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">&quot;GetProcAddress&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">0</span>], <span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">1</span>], <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">2</span>], <span class="string">&quot;www.reversecore.com&quot;</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">3</span>], <span class="string">&quot;ReverseCore&quot;</span>);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//根据我们在控制台输入的PID获取进程句柄, 参一是权限, 参二是是否继承, 参三是PID, 返回进程句柄</span></span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcess() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取参数结构体的大小</span></span><br><span class="line">    dwSize = <span class="keyword">sizeof</span>(THREAD_PARAM);</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (!(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(<span class="comment">//该函数作用是在目标进程中申请内存, 示例中是为参数结构体分配内存空间</span></span><br><span class="line">				hProcess,<span class="comment">//进程句柄</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//保留页面的内存地址,  一般NULL让系统自动分配</span></span><br><span class="line">        dwSize,<span class="comment">//想分配的内存大小</span></span><br><span class="line">        MEM_COMMIT,<span class="comment">//分配方式</span></span><br><span class="line">        PAGE_READWRITE<span class="comment">//内存属性, 示例是可读可写</span></span><br><span class="line">				))) <span class="comment">//返回值为分配内存的首地址,  放在了pRemoteBuf[0]中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">		 </span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess,<span class="comment">//将线程参数(注入代码要使用的数据)结构体写入分配的内存</span></span><br><span class="line">        pRemoteBuf[<span class="number">0</span>],<span class="comment">//写入的首地址, 就是上面分配的内存</span></span><br><span class="line">        (LPVOID)&amp;param,<span class="comment">//当前进程的参数结构体, 即要写入的数据的地址</span></span><br><span class="line">        dwSize,<span class="comment">//要写入的数据大小, 前面赋值为参数结构体的大小</span></span><br><span class="line">        <span class="literal">NULL</span><span class="comment">//实际写入数据大小存放的变量, 但是可以填不记录</span></span><br><span class="line">				))<span class="comment">//成功则返回非零值,  错误则返回0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//就是因为这个的原因，生成的时候必须用release</span></span><br><span class="line">    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;<span class="comment">//函数名就是函数的起始地址，在内存中紧跟着ThreadProc函数的就是InjectCode,所以首地址相减就能够得到ThreadProc代码占用的空间</span></span><br><span class="line">    </span><br><span class="line">		<span class="keyword">if</span> (!(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess,<span class="comment">//返回值是给代码分配的内存的首地址</span></span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        dwSize,</span><br><span class="line">        MEM_COMMIT,</span><br><span class="line">        PAGE_EXECUTE_READWRITE)))<span class="comment">//为注入代码在对应进程分配空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//向目标进程写入(注入)代码</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess,<span class="comment">//目标进程句柄</span></span><br><span class="line">        pRemoteBuf[<span class="number">1</span>],<span class="comment">//在目标进程中留给代码的内存的首地址</span></span><br><span class="line">        (LPVOID)ThreadProc,<span class="comment">//函数首地址, 要写入的代码</span></span><br><span class="line">        dwSize,<span class="comment">//写入的数据所占内存大小</span></span><br><span class="line">        <span class="literal">NULL</span>))<span class="comment">//在对应空间中写入代码</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建线程来执行在目标进程中注入的代码</span></span><br><span class="line">    <span class="keyword">if</span> (!(hThread = CreateRemoteThread(hProcess, <span class="comment">//创建远程线程执行注入代码</span></span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>],<span class="comment">//线程函数起始地址为在目标进程中注入代码的内存的首地址</span></span><br><span class="line">        pRemoteBuf[<span class="number">0</span>],<span class="comment">//传入线程函数的参数</span></span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateRemoteThread() fail : err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">		<span class="comment">//关闭线程</span></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">		<span class="comment">//关闭进程</span></span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析代码注入一些理解"><a href="#分析代码注入一些理解" class="headerlink" title="分析代码注入一些理解"></a>分析代码注入一些理解</h3><p>首先是对CreateRemoteThread()有了一些不同的看法,  之前DLL注入的时候对于CreateRemoteThread()的印象是<strong>凭空</strong>创建了一个线程(注意<strong>凭空</strong>),  但是看了代码注入后,  发现CreateRemoteThread()并不是凭空,  它有点像是一个IP寄存器,  我们把这个IP寄存器拨到内存的指定位置,  然后创建一个线程来跑这一段代码.  而这一段代码需要数据支撑,  所以它所需要的数据也必须在这个内存当中.</p>
<p>代码注入的大致流程:  给注入的代码在目标进程内分配空间 → 给需要的数据在目标进程内分配空间</p>
<pre><code>                          →调用CreateRemoteThread()创建线程,  执行该代码
</code></pre>
<h1 id="27-5-代码注入调试练习"><a href="#27-5-代码注入调试练习" class="headerlink" title="27.5    代码注入调试练习"></a>27.5    代码注入调试练习</h1><h2 id="27-5-1-调试notepad-exe"><a href="#27-5-1-调试notepad-exe" class="headerlink" title="27.5.1    调试notepad.exe"></a>27.5.1    调试notepad.exe</h2><p>先用OD调试notepad.exe文件,  使用F9让notepad.exe处于”Runing”运行中状态</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%209.png" alt="Untitled"></p>
<h2 id="27-5-3-设置OllyDbg选项"><a href="#27-5-3-设置OllyDbg选项" class="headerlink" title="27.5.3    设置OllyDbg选项"></a>27.5.3    设置OllyDbg选项</h2><p>代码注入的本质其实就是在程序中创建一个新进程,  所以我们在调试选项中开启在新线程时停止,  就可以在Threadproc(线程过程)函数处停下来了</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%2010.png" alt="Untitled"></p>
<h2 id="27-5-3-运行CodeInjection-exe"><a href="#27-5-3-运行CodeInjection-exe" class="headerlink" title="27.5.3    运行CodeInjection.exe"></a>27.5.3    运行CodeInjection.exe</h2><p>然后使用ProcessExplorer查看进程的PID</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%2011.png" alt="Untitled"></p>
<p>然后再终端处运行CodeInjection.exe(注意终端要使用管理员身份打开)</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%2012.png" alt="Untitled"></p>
<p>然后就会在我们注入的代码处停止下来</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%2013.png" alt="Untitled"></p>
<p>执行到7B0004后面</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%2014.png" alt="Untitled"></p>
<p>我们查看参数结构体的内存</p>
<p><img src="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/Untitled%2015.png" alt="Untitled"></p>
<p>至此完成调试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先在这里谈谈自己的理解</span><br><span class="line">DLL注入: 调用了CreateRemoteThread(),  创建的线程运行LoadLibraryA(), 加载了DLL后,  运行DllMain</span><br><span class="line">函数, 代码和数据都保存再DLL中,  所以不用考虑所用数据的问题</span><br><span class="line"></span><br><span class="line">代码注入: 同样调用了CreateRemoteThread(), 创建的线程运行的是自己写的函数, 所需的数据都在原本的</span><br><span class="line">程序内所以需要以参数的形式传递到函数中去,  而且需要提前保存在目标进程的内存空间中</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LamのCrow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/09/逆向工程核心原理-第 7317a/">http://example.com/2022/04/09/逆向工程核心原理-第 7317a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">LamのCrow</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">逆向工程核心原理</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2022/04/08/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2059812/"><span>逆向工程核心原理-25</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By LamのCrow</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">追求幸福</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>