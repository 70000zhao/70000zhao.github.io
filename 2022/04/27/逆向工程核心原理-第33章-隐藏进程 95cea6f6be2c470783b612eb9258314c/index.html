<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="逆向工程核心原理-33"><meta name="keywords" content="逆向工程核心原理"><meta name="author" content="LamのCrow"><meta name="copyright" content="LamのCrow"><title>逆向工程核心原理-33 | LamのCrow</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">逆向工程核心原理-第33章-隐藏进程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE"><span class="toc-number">2.</span> <span class="toc-text">回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%99%A8%E9%92%A9%E5%8F%96API"><span class="toc-number">2.1.</span> <span class="toc-text">调试器钩取API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87DLL%E4%BF%AE%E6%94%B9IAT%E9%92%A9%E5%8F%96API"><span class="toc-number">2.2.</span> <span class="toc-text">通过DLL修改IAT钩取API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-1-%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">33.1    技术图表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-2-API%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">33.2    API代码修改技术的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#33-2-1-%E9%92%A9%E5%8F%96%E4%B9%8B%E5%89%8D"><span class="toc-number">4.1.</span> <span class="toc-text">33.2.1    钩取之前</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-3-%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F"><span class="toc-number">5.</span> <span class="toc-text">33.3    进程隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#33-3-1-%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">33.3.1    进程隐藏工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-3-2-%E7%9B%B8%E5%85%B3API"><span class="toc-number">5.2.</span> <span class="toc-text">33.3.2    相关API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateToolhelp32Snapshot-amp-EnumProcess"><span class="toc-number">5.2.1.</span> <span class="toc-text">CreateToolhelp32Snapshot() &amp; EnumProcess()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ntdll-ZwQuerySystemInformation"><span class="toc-number">5.2.2.</span> <span class="toc-text">ntdll.ZwQuerySystemInformation()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-3-3-%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">33.3.3    隐藏技术的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80-%E8%A6%81%E9%92%A9%E5%8F%96%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%AA%E6%95%B0"><span class="toc-number">5.3.1.</span> <span class="toc-text">问题一:  要钩取的进程个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C-%E6%96%B0%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.3.2.</span> <span class="toc-text">问题二: 新创建的进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E5%85%A8%E5%B1%80%E9%92%A9%E5%8F%96"><span class="toc-number">5.3.3.</span> <span class="toc-text">解决方法:   全局钩取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-4-%E7%BB%83%E4%B9%A0-1-HideProc-exe-stealth-dll"><span class="toc-number">6.</span> <span class="toc-text">33.4    练习 #1 (HideProc.exe,  stealth.dll)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#33-4-1-%E8%BF%90%E8%A1%8Cnotepad-exe-procexp-exe-taskmgr-exe"><span class="toc-number">6.1.</span> <span class="toc-text">33.4.1    运行notepad.exe,  procexp.exe,  taskmgr.exe</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-5-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.</span> <span class="toc-text">33.5    源代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#33-5-1-HideProc-cpp"><span class="toc-number">7.1.</span> <span class="toc-text">33.5.1    HideProc.cpp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-5-2-stealth-cpp"><span class="toc-number">7.2.</span> <span class="toc-text">33.5.2    stealth.cpp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SetProcName-%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">SetProcName()导出函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DllMain"><span class="toc-number">7.2.2.</span> <span class="toc-text">DllMain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hook-by-code"><span class="toc-number">7.2.3.</span> <span class="toc-text">hook_by_code()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unhook-by-code"><span class="toc-number">7.2.4.</span> <span class="toc-text">unhook_by_code()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NewZwQuerySystemInformation"><span class="toc-number">7.2.5.</span> <span class="toc-text">NewZwQuerySystemInformation()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-6-%E5%85%A8%E5%B1%80API%E9%92%A9%E5%8F%96"><span class="toc-number">8.</span> <span class="toc-text">33.6    全局API钩取</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#33-6-1-Kernel32-CreateProcess-API"><span class="toc-number">8.1.</span> <span class="toc-text">33.6.1    Kernel32.CreateProcess()API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-6-2-Ntdll-ZwResumeThread-API"><span class="toc-number">8.2.</span> <span class="toc-text">33.6.2    Ntdll.ZwResumeThread()API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-7-%E7%BB%83%E4%B9%A0-2-HideProc2-exe-Stealth2-dll"><span class="toc-number">9.</span> <span class="toc-text">33.7    练习#2 (HideProc2.exe, Stealth2.dll)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#33-7-1-%E5%A4%8D%E5%88%B6stealth2-dll%E6%96%87%E4%BB%B6%E5%88%B0-SYSTEM-%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD"><span class="toc-number">9.1.</span> <span class="toc-text">33.7.1    复制stealth2.dll文件到%SYSTEM%文件夹中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-7-2-%E8%BF%90%E8%A1%8CHideProc2-exe-hide"><span class="toc-number">9.2.</span> <span class="toc-text">33.7.2    运行HideProc2.exe -hide</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-7-3-%E8%BF%90%E8%A1%8CProcExp-exe"><span class="toc-number">9.3.</span> <span class="toc-text">33.7.3    运行ProcExp.exe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-7-4-%E8%BF%90%E8%A1%8CHideProc2-exe-show"><span class="toc-number">9.4.</span> <span class="toc-text">33.7.4    运行HideProc2.exe -show</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-8-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">10.</span> <span class="toc-text">33.8    源代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#33-8-1-HideProc2-cpp"><span class="toc-number">10.1.</span> <span class="toc-text">33.8.1    HideProc2.cpp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-8-2-stealth2-cpp"><span class="toc-number">10.2.</span> <span class="toc-text">33.8.2    stealth2.cpp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DllMain-cpp"><span class="toc-number">10.2.1.</span> <span class="toc-text">DllMain.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NewCreateProcessA"><span class="toc-number">10.2.2.</span> <span class="toc-text">NewCreateProcessA()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-9-%E5%88%A9%E7%94%A8%E2%80%9D%E7%83%AD%E8%A1%A5%E4%B8%81%E2%80%9D%E6%8A%80%E6%9C%AF%E9%92%A9%E5%8F%96API"><span class="toc-number">11.</span> <span class="toc-text">33.9    利用”热补丁”技术钩取API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#33-9-1-API%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E6%8A%80%E6%9C%AF"><span class="toc-number">11.1.</span> <span class="toc-text">33.9.1    API代码修改技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-9-2-%E2%80%9C%E7%83%AD%E8%A1%A5%E4%B8%81%E2%80%9D-%E4%BF%AE%E6%94%B97%E4%B8%AA%E5%AD%97%E8%8A%82%E4%BB%A3%E7%A0%81"><span class="toc-number">11.2.</span> <span class="toc-text">33.9.2    “热补丁”(修改7个字节代码)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-11-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">12.</span> <span class="toc-text">33.11    源代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stealth3-cpp"><span class="toc-number">12.1.</span> <span class="toc-text">stealth3.cpp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hook-by-hotpatch"><span class="toc-number">12.1.1.</span> <span class="toc-text">hook_by_hotpatch()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unhook-by-hotpatch"><span class="toc-number">12.1.2.</span> <span class="toc-text">unhook_by_hotpatch()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84NewCreateProcessA"><span class="toc-number">12.1.3.</span> <span class="toc-text">修改后的NewCreateProcessA()</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s4.ax1x.com/2021/12/07/oyWTJA.jpg"></div><div class="author-info__name text-center">LamのCrow</div><div class="author-info__description text-center">欢迎交流!!!</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://space.bilibili.com/202089320">MyBIlibili</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://sma11cc.github.io/">smallcc</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">LamのCrow</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">逆向工程核心原理-33</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-27</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="逆向工程核心原理-第33章-隐藏进程"><a href="#逆向工程核心原理-第33章-隐藏进程" class="headerlink" title="逆向工程核心原理-第33章-隐藏进程"></a>逆向工程核心原理-第33章-隐藏进程</h1><span id="more"></span>

<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>中间有一周没有看这本书了前面的知识有些忘了, 所以在这里先把前面的东西缕一缕(copy)</p>
<h2 id="调试器钩取API"><a href="#调试器钩取API" class="headerlink" title="调试器钩取API"></a>调试器钩取API</h2><ul>
<li>使用DebugActiveProcess()建立起调试器被调试者的关系</li>
<li>通过DLL共享虚拟内存地址相同的特性获取到目标API的起始地址</li>
<li>修改该API的起始第一个字节为0xCC,  即INT3断点指令机器码</li>
<li>我们在调用该API时,  就会遇上这个断点指令从而将控制权交给了调试器</li>
<li>在调试器中通过ReadProcessMemory()和WriteProcessMemory()实现调试器和被调试者之间的数据交互,  从而达到修改数据的操作</li>
<li>然后脱钩,  即将0xCC改回原来的内容(通过全局变量来实现),  并将EIP减一回到断点前,  如果不脱勾的话,  当控制流从调试器转回被调试者时又会遇到INT3指令再次回到调试器钩取,  陷入死循环.</li>
<li>再根据需要决定是否要继续挂钩</li>
</ul>
<h2 id="通过DLL修改IAT钩取API"><a href="#通过DLL修改IAT钩取API" class="headerlink" title="通过DLL修改IAT钩取API"></a>通过DLL修改IAT钩取API</h2><p><strong>还是要重复:  DLL注入之所以能过如此灵活的使用于多个场景,  重要的不是在DllMain中做了什么操作,  而是在于它可以让我们可以轻易进入一个目标的虚拟空间,  并对其进行读写.</strong></p>
<ul>
<li>首先时Inject程序将我们的DLL注入到目标进程中</li>
<li>DllMain获取了我们目标API的地址(便于后面的IAT替换和恢复),  同时也轻易得到了我们的钩取函数MyFun()的地址</li>
<li>随后进入的<strong>IAT修改函数</strong>通过进程句柄的转换得到了进程的基址,  然后通过对PE头的结构体信息利用找到了IDT(导入表,  描述的是导入的全部DLL),  然后通过DLL的名称遍历筛选找到了目标API所在的DLL</li>
<li>同样通过结构体IID的成员信息找到了对应的IAT,  通过函数名称遍历筛选找到了我们的目标API在IAT表中的对应的ITD结构体,  并修改其内容:  将其中描述函数起始地址的成员修改为我们的钩取函数MyFun()的地址</li>
<li>当我们决定脱钩的时候仍然调用的是<strong>IAT修改函数</strong>,  经过同样的过程将原来的API地址恢复到IAT中</li>
</ul>
<h1 id="33-1-技术图表"><a href="#33-1-技术图表" class="headerlink" title="33.1    技术图表"></a>33.1    技术图表</h1><p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled.png" alt="Untitled"></p>
<p>我们所用到的技术仍然是DLL注入,  其作用在上面的回顾和上一章(好像)都提到过</p>
<h1 id="33-2-API代码修改技术的原理"><a href="#33-2-API代码修改技术的原理" class="headerlink" title="33.2    API代码修改技术的原理"></a>33.2    API代码修改技术的原理</h1><p>跟上一章的修改IAT技术实现钩取有相似之处,  所以理解起来会相对的简单,  但是也要注意区分二者的区别</p>
<ul>
<li>IAT通过修改IAT值来实现API钩取</li>
<li>API代码修改技术则是通过将API前5个字符修改为JMP XXXXX来钩取API(这又有点像是调试钩取API技术了,  只不过调试是只修改一个字节为0xCC),  从而将控制转移给钩取函数.</li>
</ul>
<h2 id="33-2-1-钩取之前"><a href="#33-2-1-钩取之前" class="headerlink" title="33.2.1    钩取之前"></a>33.2.1    钩取之前</h2><p>正常调用API</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%201.png" alt="Untitled"></p>
<p>钩取后</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%202.png" alt="Untitled"></p>
<p>这里看起来可能有点绕,  我们分步分析</p>
<ul>
<li>00422CF7调用了48C69C<strong>地址上的内容</strong>作为调用地址,  48C69C的内容是7C93D92E,  也就是API</li>
<li>控制流来到了7C93D92E,   而API的开头内容就是JMP 10001120,  所以我们不会执行API的内容, 而是跳至目标地址</li>
<li>跳转至10001120  这个地址就是我们的Hooking函数,  在这里我们先使用脱钩函数(这里的目的跟前面调试钩取的脱钩思路是一样的)</li>
<li>在Hooking函数中我们先调用unhook()脱钩,  因为后面还要调用到目标函数,  如果不脱勾,  API开始的内容又是JMP变成了类似无穷递归的操作(这跟上面调试脱钩是一样的道理)</li>
<li>然后在对数据进行了一系列我们想要的操作以后,  我们调用原来的API实现其功能</li>
<li>随后调用hook()重新挂钩</li>
<li>最后我们使用show参数取消挂钩,  然后在DllMain中使用另一个标签直接脱钩.</li>
</ul>
<h1 id="33-3-进程隐藏"><a href="#33-3-进程隐藏" class="headerlink" title="33.3    进程隐藏"></a>33.3    进程隐藏</h1><p>进程隐藏最常用的ntdll.ZwQuerySystemInformation()API钩取技术</p>
<h2 id="33-3-1-进程隐藏工作原理"><a href="#33-3-1-进程隐藏工作原理" class="headerlink" title="33.3.1    进程隐藏工作原理"></a>33.3.1    进程隐藏工作原理</h2><p>想要隐藏进程首先想到的方法是让目标进程隐身,  但就像是我们现实生活中一样,  隐身是不可能实现的.  所以我们用相反的方法实现隐藏进程,  那就是让其他的进程都变成瞎子,  所有的进程都看不见我们的目标进程,  那它也就相当于隐身了.</p>
<h2 id="33-3-2-相关API"><a href="#33-3-2-相关API" class="headerlink" title="33.3.2    相关API"></a>33.3.2    相关API</h2><p>进程间要检测其存在,  需要调用相关API,  这种API相当于其他进程的”眼睛”</p>
<h3 id="CreateToolhelp32Snapshot-amp-EnumProcess"><a href="#CreateToolhelp32Snapshot-amp-EnumProcess" class="headerlink" title="CreateToolhelp32Snapshot() &amp; EnumProcess()"></a>CreateToolhelp32Snapshot() &amp; EnumProcess()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用是得到系统进程快照的句柄</span></span><br><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateToolhelp32Snapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		DWORD    dwFlags,             <span class="comment">//指定获取系统进程快照的类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">		DWORD    th32ProcessID        <span class="comment">//指定要获取进程快照的ID,  获取系统内所有进程快照时是0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作用是检索系统中每个进程对象的进程标识符</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnumProcesses</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		DWORD*   pProcessIds,        <span class="comment">//指向接收进程标识符列表的数组的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">		DWORD    cb,                 <span class="comment">//pProcesslds数组的大小, 以字节为单位</span></span></span></span><br><span class="line"><span class="params"><span class="function">		DWORD*   pBytesReturned      <span class="comment">//pProcesslds数组中返回的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>上面的两个APi均在内部调用了ntdll.ZwQuerySystemInformation()API</p>
<h3 id="ntdll-ZwQuerySystemInformation"><a href="#ntdll-ZwQuerySystemInformation" class="headerlink" title="ntdll.ZwQuerySystemInformation()"></a>ntdll.ZwQuerySystemInformation()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检索指定的系统信息</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		SYSTEM_INFORMATION_CLASS    SystemInformationClass,    <span class="comment">//要检索的系统信息的类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">		PVOID    SystemInformation,                            <span class="comment">//指向接收请求信息的缓冲区的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">		ULONG    SystemInformationLength,                      <span class="comment">//描述上面参数所指向的缓冲区的大小, 以字节为单位</span></span></span></span><br><span class="line"><span class="params"><span class="function">		PULONG   ReturnLength                                  <span class="comment">//指向函数写入请求信息的实际大小的位置的可选指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>ZwQuerySystemInformation()所获取的是进程信息的链表,  所以我们要做的就是从除目标函数意外的所有函数中钩取ZwQuerySystemInformation(),  在获取的链表中删去关于目标函数的节点.  这样我们刺瞎了其他进程的眼睛(当然,  有点不恰当,  因为其他进程只是看不见目标进程,  其他的进程仍然可以看到)</p>
<h2 id="33-3-3-隐藏技术的问题"><a href="#33-3-3-隐藏技术的问题" class="headerlink" title="33.3.3    隐藏技术的问题"></a>33.3.3    隐藏技术的问题</h2><h3 id="问题一-要钩取的进程个数"><a href="#问题一-要钩取的进程个数" class="headerlink" title="问题一:  要钩取的进程个数"></a>问题一:  要钩取的进程个数</h3><p>能看到我们目标进程不只有检索进程的那些查找工具,  任何函数都可以调用ZwQuerySystemInformation()来实现查看进程</p>
<h3 id="问题二-新创建的进程"><a href="#问题二-新创建的进程" class="headerlink" title="问题二: 新创建的进程"></a>问题二: 新创建的进程</h3><p>如果用户再运行一个任务管理器,  如果没有被钩取的话,  我们隐藏进程的目的仍然没有达到.</p>
<h3 id="解决方法-全局钩取"><a href="#解决方法-全局钩取" class="headerlink" title="解决方法:   全局钩取"></a>解决方法:   全局钩取</h3><p>为了解决上面的问题,  我们隐藏test.exe进程时需要钩取系统中运行的所有进程的ZwQuerySystemInformation()API,  并且对后面将要启动运行的所有进程进行相同的操作.  这就是全局钩取的概念.</p>
<h1 id="33-4-练习-1-HideProc-exe-stealth-dll"><a href="#33-4-练习-1-HideProc-exe-stealth-dll" class="headerlink" title="33.4    练习 #1 (HideProc.exe,  stealth.dll)"></a>33.4    练习 #1 (HideProc.exe,  stealth.dll)</h1><ul>
<li>HideProc.exe负责将stealth.dll文件注入到所有运行中的进程.</li>
<li>stealth.dll负责钩取进程的ntdll.ZwQuerySystemInformation()</li>
</ul>
<h2 id="33-4-1-运行notepad-exe-procexp-exe-taskmgr-exe"><a href="#33-4-1-运行notepad-exe-procexp-exe-taskmgr-exe" class="headerlink" title="33.4.1    运行notepad.exe,  procexp.exe,  taskmgr.exe"></a>33.4.1    运行notepad.exe,  procexp.exe,  taskmgr.exe</h2><p>首先将HideProc.exe跟stealth.dll放入同一个文件夹</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%203.png" alt="Untitled"></p>
<p>随后打开notepad.exe文件</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%204.png" alt="Untitled"></p>
<p>使用procxp查看进程</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%205.png" alt="Untitled"></p>
<p>此时procxp是可以检测到notepad的</p>
<p>然后我们开始钩取API</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%206.png" alt="Untitled"></p>
<p>再次使用procxp查看进程</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%207.png" alt="Untitled"></p>
<p>此时procxp不能检测到notepad</p>
<p>我们查看有哪些进程是被注入了stealth.dll的</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%208.png" alt="Untitled"></p>
<p>可以看到我们用来检索notepad的procxp被注入了stealth.dll,  所以才没有检索到notepad进程</p>
<p>接下来我们停止隐藏进程</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%209.png" alt="Untitled"></p>
<p>再次使用procxo查看进程</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%2010.png" alt="Untitled"></p>
<p>此时notepad再一次出现了</p>
<h1 id="33-5-源代码分析"><a href="#33-5-源代码分析" class="headerlink" title="33.5    源代码分析"></a>33.5    源代码分析</h1><h2 id="33-5-1-HideProc-cpp"><a href="#33-5-1-HideProc-cpp" class="headerlink" title="33.5.1    HideProc.cpp"></a>33.5.1    HideProc.cpp</h2><p>HideProc.exe负责向运行中的所有进程注入/卸载指定DLL文件,  它再原有InjectDll.exe的基础上添加了向所有进程注入DLL的功能,  可以认为是InjectDll.exe程序的加强版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InjectAllProcess</span><span class="params">(<span class="keyword">int</span> nMode, LPCTSTR szDllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD              dwPID = <span class="number">0</span>;<span class="comment">//进程PID</span></span><br><span class="line">	HANDLE             hSnapShot = INVALID_HANDLE_VALUE;<span class="comment">//初始化系统快照句柄</span></span><br><span class="line">	PROCESSENTRY32     pe;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 作用是描述快照中的进程列表中的条目结构体</span></span><br><span class="line"><span class="comment">	typedef struct tagPROCESSENTRY32 &#123;</span></span><br><span class="line"><span class="comment">  DWORD     dwSize;                 //该结构的大小</span></span><br><span class="line"><span class="comment">  DWORD     cntUsage;				//弃用, 始终为0</span></span><br><span class="line"><span class="comment">  DWORD     th32ProcessID;			//该进程的PID</span></span><br><span class="line"><span class="comment">  ULONG_PTR th32DefaultHeapID;		//弃用, 始终为0</span></span><br><span class="line"><span class="comment">  DWORD     th32ModuleID;			//弃用, 始终为0</span></span><br><span class="line"><span class="comment">  DWORD     cntThreads;				//进程启动的执行线程数</span></span><br><span class="line"><span class="comment">  DWORD     th32ParentProcessID;	//父进程PID, 即PPID</span></span><br><span class="line"><span class="comment">  LONG      pcPriClassBase;			//此进程创建的任何线程的基本优先级</span></span><br><span class="line"><span class="comment">  DWORD     dwFlags;				//弃用, 始终为0</span></span><br><span class="line"><span class="comment">  CHAR      szExeFile[MAX_PATH];	//进程的可执行文件的名称</span></span><br><span class="line"><span class="comment">&#125; PROCESSENTRY32;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//获取系统快照</span></span><br><span class="line">	pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);<span class="comment">//获取描述进程的结构体的内存大小, 并给dwSize成员, 防止报错</span></span><br><span class="line">	hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, <span class="literal">NULL</span>);<span class="comment">//获取系统快照</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找进程</span></span><br><span class="line">	Process32First(hSnapShot, &amp;pe);<span class="comment">//首先获取第一个进程信息结构体</span></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		dwPID = pe.th32ProcessID;<span class="comment">//从进程信息结构体中获取对应进程的PID</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//鉴于系统安全性的考虑, 对于PID小于100的系统进程不执行DLL注入操作</span></span><br><span class="line">		<span class="keyword">if</span> (dwPID &lt; <span class="number">100</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nMode == INJECTION_MODE)<span class="comment">//根据这个传入的参数来决定是注入还是卸载</span></span><br><span class="line">			InjectDll(dwPID, szDllPath);<span class="comment">//注入DLL</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			EjectDll(dwPID, szDllPath);<span class="comment">//卸载DLL</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (Process32Next(hSnapShot, &amp;pe));<span class="comment">//获取下一个进程信息结构体</span></span><br><span class="line"></span><br><span class="line">	CloseHandle(hSnapShot);<span class="comment">//关闭系统快照句柄</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;<span class="comment">//返回值为真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是对全部(除了特殊的进程)进程注入或者是卸载stealth.dll</p>
<p>我们来到下一个源码分析</p>
<h2 id="33-5-2-stealth-cpp"><a href="#33-5-2-stealth-cpp" class="headerlink" title="33.5.2    stealth.cpp"></a>33.5.2    stealth.cpp</h2><p>实际的API钩取操作由Stealth.dll文件负责</p>
<h3 id="SetProcName-导出函数"><a href="#SetProcName-导出函数" class="headerlink" title="SetProcName()导出函数"></a>SetProcName()导出函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global variable (in sharing memory)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">&quot;/SECTION:.SHARE,RWS&quot;</span>)<span class="comment">//当第一个参数为linker表示链接器选项, </span></span></span><br><span class="line"><span class="comment">///SECTION表示更改节的属性, RWS表示Read可读, W表示Write可写, S表示Shared共享 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.SHARE&quot;</span>)</span></span><br><span class="line">    TCHAR g_szProcName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;<span class="comment">//建立g_szProcName缓冲区</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export function 导出函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus<span class="comment">//__cplusplus表示这是第一段C++代码, 这样的意义是: 如果这是一段cpp代码, 就加入extern&quot;C&quot;&#123;和&#125;处理其中的代码</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;<span class="comment">//这个的作用是告诉链接器, 这是一个用C语言写的代码, 要用C语言的方式去链接它, 而前提条件是上面的&quot;如果这是一段C++代码&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">SetProcName</span><span class="params">(LPCTSTR szProcName)</span><span class="comment">//导出函数, 作用是将隐藏的进程名称保存再g_szProcName数组中</span></span></span><br><span class="line"><span class="function"></span>&#123;                     <span class="comment">//这个函数在HideProc()中被调用执行</span></span><br><span class="line">    _tcscpy_s(g_szProcName, szProcName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>下面我们看DllMain函数</p>
<h3 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>     szCurProc[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span>     * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常处理: 若当前进程为HideProc.exe,  则终止, 不进行钩取操作</span></span><br><span class="line">    GetModuleFileNameA(<span class="literal">NULL</span>, szCurProc, MAX_PATH);<span class="comment">//查找当前进程的文件名</span></span><br><span class="line">    p = <span class="built_in">strrchr</span>(szCurProc, <span class="string">&#x27;\\&#x27;</span>);<span class="comment">//获取路径中文件名的前一个地址</span></span><br><span class="line">    <span class="keyword">if</span> ((p != <span class="literal">NULL</span>) &amp;&amp; !_stricmp(p + <span class="number">1</span>, <span class="string">&quot;HideProc.exe&quot;</span>))<span class="comment">//用前一个地址来找到文件名并跟HideProc作比较</span></span><br><span class="line">        <span class="keyword">return</span> TRUE;<span class="comment">//如果是HideProc就返回为真直接退出, 不对HideProc进程钩取API</span></span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//API钩取</span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, </span><br><span class="line">                     (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="comment">//API脱钩</span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在进入了DllMain后还会通过进程文件名来对进程进行一次筛选,  如果是HideProc.exe注入程序本身就会跳过注入.</p>
<p>ATTCH附加则调用hook_by_code实现API钩取,  DETACH脱离则调用unhook_by_code()实现API脱钩</p>
<p>下面是对两个函数进行解析</p>
<h3 id="hook-by-code"><a href="#hook-by-code" class="headerlink" title="hook_by_code()"></a>hook_by_code()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           目标API所在DLL的名称指针 目标API的名称指针   钩取函数的地址  存储原有代码的内存的缓冲区指针</span></span><br><span class="line"><span class="function">BOOL <span class="title">hook_by_code</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FARPROC    pfnOrg;<span class="comment">//用于存储目标API的地址</span></span><br><span class="line">    DWORD      dwOldProtect, dwAddress;</span><br><span class="line">    byte       pBuf[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0</span>, &#125;;</span><br><span class="line">    PBYTE      pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取要钩取的API地址</span></span><br><span class="line">    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName),<span class="comment">//通过名称调用两个Getxxx函数获取API的地址</span></span><br><span class="line">                                      szFuncName);</span><br><span class="line">    pByte = (PBYTE)pfnOrg;<span class="comment">//转换类型: 从一个WINAPI类型的指针转换成了字节指针, 方便后面对内存进行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//若已经被钩取, 则返回FALSE</span></span><br><span class="line">    <span class="keyword">if</span> (pByte[<span class="number">0</span>] = <span class="number">0xE9</span>)<span class="comment">//E9就是JMP的字节码, 正常的API哪会上来就跳转, 所以通过首地址的内容判断是否已被钩取</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了修改5个字节, 先向内存添加&quot;写&quot;属性</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<span class="comment">//改变内存保护属性(权限), 这里是将其设为可读可写, 同时将旧保护属性存储在dwOldProtect结构体中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份原有代码(5字节)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pOrgBytes, pfnOrg, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算JMP地址(E9 XXXXXXXX)</span></span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - <span class="number">5</span>;<span class="comment">//这里的跳转字节码用的是相对地址, 其值为 = 函数地址跟下条指令之间的距离, 所以还需要减5表示去掉指令本身的长度</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;pBuf[<span class="number">1</span>], &amp;dwAddress, <span class="number">4</span>);<span class="comment">//添加上这四个字节的内容pBuf就是一条完整的跳转指令了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//钩子: 修改5个字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pfnOrg, pBuf, <span class="number">5</span>);<span class="comment">//将我们的jmp字节码修改到API的开头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复内存属性</span></span><br><span class="line">    VirtualProtect((LPVOID)pfnOrg, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);<span class="comment">//参三一个选项, 只是接下来的造作方式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致思路</p>
<ul>
<li>获取目标API首地址</li>
<li>查看是否已经注入</li>
<li>修改内存属性</li>
<li>计算JMP地址</li>
<li>挂钩(将JMP修改到API首地址)</li>
<li>恢复内存属性</li>
</ul>
<h3 id="unhook-by-code"><a href="#unhook-by-code" class="headerlink" title="unhook_by_code()"></a>unhook_by_code()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">unhook_by_code</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)</span><span class="comment">//比钩取函数少了一个钩取函数地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FARPROC    pFunc;</span><br><span class="line">    DWORD      dwOldProtect;</span><br><span class="line">    PBYTE      pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取API地址</span></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);<span class="comment">//通过参一参二两个字符串指针得到了API首地址</span></span><br><span class="line">    pByte = (PBYTE)pFunc;<span class="comment">//转换类型: 从一个WINAPI类型的指针转换成了字节指针, 方便后面对内存进行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pByte[<span class="number">0</span>] != <span class="number">0xE9</span>)<span class="comment">//如果开头不是JMP指令, 说明还没有挂钩, 所以不用脱钩直接退出</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向内存添加&quot;写&quot;属性, 为恢复代码做准备</span></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//脱钩</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pFunc, pOrgBytes, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复内存属性</span></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unhook_by_code()跟hook_by_code几乎是一模一样</p>
<ul>
<li>获取目标API首地址</li>
<li>查看是否有注入</li>
<li>修改内存属性</li>
<li>脱钩</li>
<li>恢复内存属性</li>
</ul>
<h3 id="NewZwQuerySystemInformation"><a href="#NewZwQuerySystemInformation" class="headerlink" title="NewZwQuerySystemInformation()"></a>NewZwQuerySystemInformation()</h3><p>最后, 分析钩取函数NewZwQuerySystemInformation(),  在这之前再次看看ntdll.ZwQuerySystemInformation()API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">ZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	__in        SYSTEM_INFORMATION_CLASS SystemInformationClass,<span class="comment">//要检索的系统信息的类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__inout     PVOID SystemInformation,<span class="comment">//指向接收请求信息的缓冲区的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__in        ULONG SystemInformationLength,<span class="comment">//描述上面参数所指向的缓冲区的大小, 以字节为单位</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__out_opt   PULONG ReturnLength<span class="comment">//指向函数写入请求信息的实际大小的位置的可选指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//系统进程信息结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">		ULONG NextEntryOffset;<span class="comment">//当前节点的地址加上NextEntryOffset就是下一个节点的起始地址</span></span><br><span class="line">		ULONG NumberOfThreads;<span class="comment">//描述该进程中的线程数</span></span><br><span class="line">		byte Reserved1[<span class="number">48</span>];<span class="comment">//保留</span></span><br><span class="line">		PVOID Reserved2[<span class="number">3</span>];<span class="comment">//保留, 类型为指针, 根据下面的源代码1号元素存有进程名字符串指针</span></span><br><span class="line">		HANDLE UniqueProcessId;<span class="comment">//PID</span></span><br><span class="line">		PVOID Reserved3;<span class="comment">//保留</span></span><br><span class="line">		ULONG HandleCount;<span class="comment">//描述进程正在使用的句柄总是</span></span><br><span class="line">		byte Reserved4[<span class="number">4</span>];<span class="comment">//保留</span></span><br><span class="line">		Pvoid Reserved5[<span class="number">11</span>];<span class="comment">//保留</span></span><br><span class="line">		SIZE_T PeakPagefileUsage;<span class="comment">//描述进程正在使用页面文件存储的字节数</span></span><br><span class="line">		SIZE_T PrivatePageCount;<span class="comment">//描述分配给进程使用的内存页数</span></span><br><span class="line">		LARGE_INTEGER Reserved6[<span class="number">6</span>];<span class="comment">//保留</span></span><br><span class="line">	&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>下面是我们的NewZwQuerySystemInformation()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">NewZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID SystemInformation<span class="comment">//进程信息单项链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG SystemInformationLength,<span class="comment">//表示的就是unsigned long</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PULONG ReturnLength<span class="comment">//表示是unsigned long的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;</span><br><span class="line">    <span class="keyword">char</span> szProcName[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在开始前先脱钩</span></span><br><span class="line">    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用原始API</span></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL), DEF_ZWQUERYSYSTEMINFORMATION);</span><br><span class="line"></span><br><span class="line">    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)<span class="comment">//通过函数起始地址调用原来的API</span></span><br><span class="line">        (SystemInformationClass, SystemInformation,</span><br><span class="line">            SystemInformationLength, ReturnLength);<span class="comment">//返回值: NTSTATUS成功或者错误代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != STATUS_SUCCESS)<span class="comment">//如果调用该API失败, 则直接跳转到结尾</span></span><br><span class="line">        <span class="keyword">goto</span> __NTQUERYSYSTEMINFORMATION_END;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仅针对SystemProcessInformation类型操作</span></span><br><span class="line">    <span class="keyword">if</span> (SystemInformationClass == SystemProcessInformation)<span class="comment">//确定获取的系统信息是进程信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过类型转换获取到pCur单项链表的头</span></span><br><span class="line">        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pCur-&gt;Reserved2[<span class="number">1</span>] != <span class="literal">NULL</span>)<span class="comment">//Reserved2[1]存有进程名字符串指针</span></span><br><span class="line">            &#123;   <span class="comment">//g_szProcName是目标进程名的字符串指针, 这里是根据名称比较来确定是否是需要隐藏的进程节点</span></span><br><span class="line">                <span class="keyword">if</span> (!_tcsicmp((PWSTR)pCur-&gt;Reserved2[<span class="number">1</span>], g_szProcName))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)<span class="comment">//如果是最后的节点就直接删除并让上一个节点变成末节点</span></span><br><span class="line">                        pPrev-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">//如果是中间的节点就要让上一个节点跳过这个节点</span></span><br><span class="line">                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pPrev = pCur;<span class="comment">//如果不是我们要找的节点的话我们就换下一个</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pCur-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            pCur = (PSYSTEM_PROCESS_INFORMATION)((ULONG)pCur + pCur-&gt;NextEntryOffset);<span class="comment">//获取链表的下一项</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">__NTQUERYSYSTEMINFORMATION_END:</span><br><span class="line">    <span class="comment">//函数终止前, 再次执行API钩取操作,为下一次调用做准备</span></span><br><span class="line">    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,</span><br><span class="line">        (PROC)NewZwQuerySystemInformation, g_pOrgBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致流程:</p>
<ul>
<li>首先脱钩, 为了后面能正常使用函数,  而不是无限递归</li>
<li>然后通过Loadxxx获取到了隐藏API的地址</li>
<li>通过地址<strong>正常</strong>调用了API</li>
<li>获取进程信息链表</li>
<li>通过名称字符串对比找到了隐藏进程所在节点,  并删去,  这时我们的隐藏进程对于当前进程来说就是不存在的了</li>
<li>重新挂钩</li>
</ul>
<p>我之前对于ZwQuerySystemInformation()的理解有点误区,  那就是我认为进程信息的链表是全局的,  也就是说只用需改一次就可以了,  但是实际上并不是,  ZwQuerySystemInformation()的工作原理是获取当前的进程信息组成局部链表,  然后给其他的API使用,  如果下一次没有过去的话,  ZwQuerySystemInformation()又会重新获取新的进程信息链表, 这时该链表中又有我们想要隐藏的进程信息了,  所以我们每次调用ZwQuerySystemInformation()时都需要重复钩取.</p>
<h1 id="33-6-全局API钩取"><a href="#33-6-全局API钩取" class="headerlink" title="33.6    全局API钩取"></a>33.6    全局API钩取</h1><p>全局钩取的对象有两个:</p>
<ul>
<li>当前运行的所有进程</li>
<li>将来要运行的所有进程</li>
</ul>
<p>我们前面只完成了第一个目标,  接下来我们将<strong>在此基础上</strong>完成第二个目标.</p>
<h2 id="33-6-1-Kernel32-CreateProcess-API"><a href="#33-6-1-Kernel32-CreateProcess-API" class="headerlink" title="33.6.1    Kernel32.CreateProcess()API"></a>33.6.1    Kernel32.CreateProcess()API</h2><p>Kernel32.CreateProcess()API用来创建新进程.其他创建进程的API内部都调用了这个API</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CreateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	__in_opt        LPCTSTR lpApplicationName,<span class="comment">//要执行的模块的完整的路径名和文件名</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__inout_opt     LPTSTR lpCommandLine,<span class="comment">//要执行的命令行</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__in_opt        LPSECURITY_ATTRIBUTES lpProcessAttributes,<span class="comment">//指向**进程**的安全描述符结构体的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__in_opt        LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="comment">//指向**线程**的安全描述符结构体的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__in            BOOL bInheritHandles,<span class="comment">//为TRUE则进程中的每个可继承句柄都有子进程继承, 为FALSE则相反</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__in            DWORD dwCreationFlags,<span class="comment">//控制优先级和进程创建的标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__in_opt        LPVOID lpEnvironment,<span class="comment">//指向新进程的环境快指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__in_opt        LPCTSTR lpCurrentDirectory,<span class="comment">//进程当前目录的完整路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__in            LPSTARTUPINFO lpStartupInfo,<span class="comment">//指向STARTUPINFOA或STARTUPINFOEXA结构体, 这两个结构体都是描述新进程的窗口, 桌面, 标准句柄和属性的</span></span></span></span><br><span class="line"><span class="params"><span class="function">	__out           LPPROCESS_INFORMATION lpProcessInformation<span class="comment">//指向PROCESS_INFORMATION结构体指针, 该结构体接收有关新进程的标识信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因此, 向当前运行的所有进程注入stealth.dll后,  如果在stealth.dll中将CreateProcess()API也一起钩取,  那么以后运行的进程也会自动注入stealth.dll文件.</p>
<p>但是要考虑以下方面:</p>
<ul>
<li>钩取CreateProcess()API时,  还要分别钩取CreateProcessA(),  CreateProcessW()这两个API</li>
<li>CreateProcessA(),  CreateProcessW()中又分别调用了CreateProcessInternalA(),  CreateProcessInternalW()这两个函数.</li>
<li>钩取函数(NewCreateProcess)要钩取子进程的API.  因此,  极短时间内,  子进程可能在未钩取的状态下运行.</li>
</ul>
<p>对于上面的问题,  有一个一次性解决的方法,  那就是钩取比CreateProcess()更低级的API</p>
<h2 id="33-6-2-Ntdll-ZwResumeThread-API"><a href="#33-6-2-Ntdll-ZwResumeThread-API" class="headerlink" title="33.6.2    Ntdll.ZwResumeThread()API"></a>33.6.2    Ntdll.ZwResumeThread()API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZwResumeThread(</span><br><span class="line">		IN     HANDLE     ThreadHandle,</span><br><span class="line">		OUT    PULONG     SuspendCount OPTIONAL</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>ZwResumeThread()是在进程创建后,  主线程运行前被调用执行.  所以只用钩取这个函数,  即可在不运行子进程代码的状态下钩取API.</p>
<p>在读书的时候读到这里会有点晕,  首先对于子进程,  我们的目标是钩取子进程的API,  而钩取API所要做的事就是注入DLL,  而我们想要达成注入DLL到子进程中所要做的事是在父进程中钩取创建子进程的API,  然后在钩取函数中调用Loadxxx.  这样捋下来就是:  <strong>我们要在父进程中额外钩取API,  这一个钩取函数的行为是在子进程中再一次注入DLL钩取API,  同时子进程中也会发生同样的操作.</strong>  </p>
<h1 id="33-7-练习-2-HideProc2-exe-Stealth2-dll"><a href="#33-7-练习-2-HideProc2-exe-Stealth2-dll" class="headerlink" title="33.7    练习#2 (HideProc2.exe, Stealth2.dll)"></a>33.7    练习#2 (HideProc2.exe, Stealth2.dll)</h1><h2 id="33-7-1-复制stealth2-dll文件到-SYSTEM-文件夹中"><a href="#33-7-1-复制stealth2-dll文件到-SYSTEM-文件夹中" class="headerlink" title="33.7.1    复制stealth2.dll文件到%SYSTEM%文件夹中"></a>33.7.1    复制stealth2.dll文件到%SYSTEM%文件夹中</h2><p>为了把stealth2.dll文件注入所有运行进程,  首先要把stealth2.dll文件复制到%SYSTEM%文件夹</p>
<h2 id="33-7-2-运行HideProc2-exe-hide"><a href="#33-7-2-运行HideProc2-exe-hide" class="headerlink" title="33.7.2    运行HideProc2.exe -hide"></a>33.7.2    运行HideProc2.exe -hide</h2><p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%2011.png" alt="Untitled"></p>
<h2 id="33-7-3-运行ProcExp-exe"><a href="#33-7-3-运行ProcExp-exe" class="headerlink" title="33.7.3    运行ProcExp.exe"></a>33.7.3    运行ProcExp.exe</h2><p>这时再运行ProcExp看是否是全局钩取</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%2012.png" alt="Untitled"></p>
<p>可以看到即使是钩取后的进程也依然被钩取了</p>
<h2 id="33-7-4-运行HideProc2-exe-show"><a href="#33-7-4-运行HideProc2-exe-show" class="headerlink" title="33.7.4    运行HideProc2.exe -show"></a>33.7.4    运行HideProc2.exe -show</h2><p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%2013.png" alt="Untitled"></p>
<p>在取消钩取后又可以看到notepad了</p>
<h1 id="33-8-源代码分析"><a href="#33-8-源代码分析" class="headerlink" title="33.8    源代码分析"></a>33.8    源代码分析</h1><h2 id="33-8-1-HideProc2-cpp"><a href="#33-8-1-HideProc2-cpp" class="headerlink" title="33.8.1    HideProc2.cpp"></a>33.8.1    HideProc2.cpp</h2><p>和HideProc.cpp相比,  HideProc2.cpp只是减少了参数个数,  内容跟HideProc差不多,  所以可以参照上面的内容</p>
<h2 id="33-8-2-stealth2-cpp"><a href="#33-8-2-stealth2-cpp" class="headerlink" title="33.8.2    stealth2.cpp"></a>33.8.2    stealth2.cpp</h2><h3 id="DllMain-cpp"><a href="#DllMain-cpp" class="headerlink" title="DllMain.cpp"></a>DllMain.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> szCurProc[MAX_PATH] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异常处理使注入不会发生在HideProc2.exe进程</span></span><br><span class="line">    GetModuleFileNameA(<span class="literal">NULL</span>, szCurProc, MAX_PATH);<span class="comment">//获取当前进程的文件路径(这里已经开始钩取了, 对每个进程注入DLL是HideProc的功能)</span></span><br><span class="line">    p = <span class="built_in">strrchr</span>(szCurProc, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((p != <span class="literal">NULL</span>) &amp;&amp; !_stricmp(p + <span class="number">1</span>, <span class="string">&quot;HideProc2.exe&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变privilege</span></span><br><span class="line">    SetPrivilege(SE_DEBUG_NAME, TURE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="comment">//钩取</span></span><br><span class="line">        hook_by_code(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="string">&quot;CreateProcessA&quot;</span>, (PROC)NewCreateProcessA, g_pOrgCPA);<span class="comment">//对创建进程的API进行钩取</span></span><br><span class="line"></span><br><span class="line">        hook_by_code(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="string">&quot;CreateProcessW&quot;</span>, (PROC)NewCreateProcessW, g_pOrgCPW);<span class="comment">//对创建进程的API进行钩取</span></span><br><span class="line"></span><br><span class="line">        hook_by_code(<span class="string">&quot;ntdll.dll&quot;</span>, <span class="string">&quot;ZwQuerySystemInformation&quot;</span>, (PROC)NewZwoQuerySystemInformation, g_pOrgZwQSI);<span class="comment">//对检索进程的API进行钩取</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="comment">//脱钩</span></span><br><span class="line">        unhook_by_code(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="string">&quot;CreateProcessA&quot;</span>, g_pOrgCPA);</span><br><span class="line"></span><br><span class="line">        unhook_by_code(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="string">&quot;CreateProcessW&quot;</span>, g_pOrgCPW);</span><br><span class="line"></span><br><span class="line">        unhook_by_code(<span class="string">&quot;ntdll.dll&quot;</span>, <span class="string">&quot;ZwQuerySystemInformation&quot;</span>, g_pOrgZwQSI);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NewCreateProcessA"><a href="#NewCreateProcessA" class="headerlink" title="NewCreateProcessA()"></a>NewCreateProcessA()</h3><p>针对创建进程API的钩取函数的源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR                lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR                 lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                 dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID                lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR                lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTARTUPINFOA        lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//脱钩(针对当前进程)</span></span><br><span class="line">    unhook_by_code(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="string">&quot;CreateProcessA&quot;</span>, g_pOrgCPA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取原函数的指针</span></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;CreateProcessA&quot;</span>);</span><br><span class="line">    <span class="comment">//通过指针调用了该函数(已经脱钩),  生成子进程, 若成功则返回一个非零值, 失败则相反</span></span><br><span class="line">    bRet = ((PFCREATEPROCESSA)pFunc)(</span><br><span class="line">        lpApplicationName,</span><br><span class="line">        lpCommandLine,</span><br><span class="line">        lpProcessAttributes,</span><br><span class="line">        lpThreadAttributes,</span><br><span class="line">        bInheritHandles,</span><br><span class="line">        dwCreationFlags,</span><br><span class="line">        lpEnvironment,</span><br><span class="line">        lpCurrentDirectory,</span><br><span class="line">        lpStartupInfo,</span><br><span class="line">        lpProcessInformation);<span class="comment">//这个结构体负责存储子进程的信息, 在下面的作用是获取子进程PID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向生成的子进程注入stealth2.dll(针对子进程)</span></span><br><span class="line">    <span class="keyword">if</span> (bRet)<span class="comment">//如果成功创建子进程</span></span><br><span class="line">        InjectDll2(lpProcessInformation-&gt;hProcess, Str_MODULE_NAME);<span class="comment">//参一的结构体赋值是在上面的函数调用中实现的, 这个结构体是最后一个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//钩取(针对当前进程)</span></span><br><span class="line">    hook_by_code(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="string">&quot;CreateProcessA&quot;</span>, (PROC)NewCreateProcessA, g_pOrgCPA);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致思路:</p>
<ul>
<li>在当前进程中对<strong>创建进程API</strong>脱钩,  防止无限递归</li>
<li>然后调用脱钩后的原API创建子进程</li>
<li>通过PID对该子进程进程DLL注入,  钩取了子进程的<strong>检索进程函数</strong>和<strong>创建进程函数</strong></li>
<li>在当前进程中对创建进程挂钩</li>
</ul>
<h1 id="33-9-利用”热补丁”技术钩取API"><a href="#33-9-利用”热补丁”技术钩取API" class="headerlink" title="33.9    利用”热补丁”技术钩取API"></a>33.9    利用”热补丁”技术钩取API</h1><h2 id="33-9-1-API代码修改技术"><a href="#33-9-1-API代码修改技术" class="headerlink" title="33.9.1    API代码修改技术"></a>33.9.1    API代码修改技术</h2><p>由于线程问题,  在对API进行写的操作的同时,  运行代码会引发错误,  所以需要跟安全的API钩取技术.</p>
<h2 id="33-9-2-“热补丁”-修改7个字节代码"><a href="#33-9-2-“热补丁”-修改7个字节代码" class="headerlink" title="33.9.2    “热补丁”(修改7个字节代码)"></a>33.9.2    “热补丁”(修改7个字节代码)</h2><p>我们观察API的结构</p>
<p><img src="/2022/04/27/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC33%E7%AB%A0-%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%2095cea6f6be2c470783b612eb9258314c/Untitled%2014.png" alt="Untitled"></p>
<p>可以发现又7个字节的空余,  这些专门用于热补丁的</p>
<p>思路(二次跳转)</p>
<ul>
<li>前面5个字节用于JMP</li>
<li>后面2个字节用于JMP SHORT,  跳转的目的就是前面的5字节JMP</li>
</ul>
<p>跟代码修改JMP之间的区别在于,  这个API是可以正常运行原有功能的,  因为下面的指令都没有被破坏,  然后如果想要正常调用不需要再脱钩挂钩,  直接起始地址 + 2 就可调用了.</p>
<h1 id="33-11-源代码分析"><a href="#33-11-源代码分析" class="headerlink" title="33.11    源代码分析"></a>33.11    源代码分析</h1><h2 id="stealth3-cpp"><a href="#stealth3-cpp" class="headerlink" title="stealth3.cpp"></a>stealth3.cpp</h2><h3 id="hook-by-hotpatch"><a href="#hook-by-hotpatch" class="headerlink" title="hook_by_hotpatch()"></a>hook_by_hotpatch()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">hook_by_hotpatch</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect, dwAddress;</span><br><span class="line">    BYTE pBuf[<span class="number">5</span>] = &#123; <span class="number">0xE9</span> , <span class="number">0</span> &#125;;<span class="comment">//第二次跳转, 调转到hook函数</span></span><br><span class="line">    byte pBuf2[<span class="number">2</span>] = &#123; <span class="number">0xEB</span>, <span class="number">0xF9</span> &#125;;<span class="comment">//第一次跳转的字节码, 因为相对地址是固定的, 所以可以直接确定机器码</span></span><br><span class="line">    PBYTE pByte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取目标API的首地址</span></span><br><span class="line">    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    <span class="comment">//类型转换</span></span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line">    <span class="comment">//检查是否已经挂钩, 如果挂钩内存内容就是0xEB短跳转</span></span><br><span class="line">    <span class="keyword">if</span> (pByte[<span class="number">0</span>] == <span class="number">0xEB</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">//改变那7个字节的保护属性</span></span><br><span class="line">    VirtualProtect((LPVOID)((DWORD)pFunc - <span class="number">5</span>), <span class="number">7</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变上面的五个字节</span></span><br><span class="line">    dwAddress = (DWORD)pfnNew - (DWORD)pFunc;<span class="comment">//计算出要跳转的偏移, 这里不用减5是因为跳转后的下一条指令就是函数的开头</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;pBuf[<span class="number">1</span>], &amp;dwAddress, <span class="number">4</span>);<span class="comment">//将地址赋给数组</span></span><br><span class="line">    <span class="built_in">memcpy</span>((LPVOID)((DWORD)pFunc - <span class="number">5</span>), pBuf, <span class="number">5</span>);<span class="comment">//将数组赋值给内存</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(pFunc, pBuf2, <span class="number">2</span>);<span class="comment">//将API开头两个字节修改</span></span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)((DWORD)pFunc - <span class="number">5</span>), <span class="number">7</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟之前的钩取函数差不多,  只是修改了7个字节</p>
<h3 id="unhook-by-hotpatch"><a href="#unhook-by-hotpatch" class="headerlink" title="unhook_by_hotpatch()"></a>unhook_by_hotpatch()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">unhook_by_hotpatch</span><span class="params">(LPCSTR szDllName, LPCSTR szFuncName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    PBYTE pByte;</span><br><span class="line">    byte pBuf[<span class="number">5</span>] = &#123; <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span> &#125;;<span class="comment">//恢复的API开头之前的5个NOP</span></span><br><span class="line">    byte pBuf2[<span class="number">2</span>] = &#123; <span class="number">0x8b</span>, <span class="number">0xFF</span> &#125;;<span class="comment">//恢复的API开头两个字节</span></span><br><span class="line">    <span class="comment">//获取需要恢复的API地址</span></span><br><span class="line">    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);</span><br><span class="line">    <span class="comment">//类型转换</span></span><br><span class="line">    pByte = (PBYTE)pFunc;</span><br><span class="line">    <span class="comment">//判断是否挂钩</span></span><br><span class="line">    <span class="keyword">if</span> (pByte[<span class="number">0</span>] != <span class="number">0xEB</span>)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">//修改内存保护属性</span></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复前五个字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>((LPVOID)((DWORD)pFunc - <span class="number">5</span>), pBuf, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复MOV EDI, EDI</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pFunc, pBuf2, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    VirtualProtect((LPVOID)pFunc, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改后的NewCreateProcessA"><a href="#修改后的NewCreateProcessA" class="headerlink" title="修改后的NewCreateProcessA()"></a>修改后的NewCreateProcessA()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR                lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR                 lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                 dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID                lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR                lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTARTUPINFOA        lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet;</span><br><span class="line">    FARPROC pFunc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取原函数的指针</span></span><br><span class="line">    pFunc = GetProcAddress(GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;CreateProcessA&quot;</span>);</span><br><span class="line">    <span class="comment">//原API的地址现在设置为: 起始地址 + 2</span></span><br><span class="line">    pFunc = (FARPROC)((DWORD)pFunc + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//通过指针调用了该函数(已经脱钩),  生成子进程, 若成功则返回一个非零值, 失败则相反</span></span><br><span class="line">    bRet = ((PFCREATEPROCESSA)pFunc)(</span><br><span class="line">        lpApplicationName,</span><br><span class="line">        lpCommandLine,</span><br><span class="line">        lpProcessAttributes,</span><br><span class="line">        lpThreadAttributes,</span><br><span class="line">        bInheritHandles,</span><br><span class="line">        dwCreationFlags,</span><br><span class="line">        lpEnvironment,</span><br><span class="line">        lpCurrentDirectory,</span><br><span class="line">        lpStartupInfo,</span><br><span class="line">        lpProcessInformation);<span class="comment">//这个结构体负责存储子进程的信息, 在下面的作用是获取子进程PID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向生成的子进程注入stealth2.dll(针对子进程)</span></span><br><span class="line">    <span class="keyword">if</span> (bRet)<span class="comment">//如果成功创建子进程</span></span><br><span class="line">        InjectDll2(lpProcessInformation-&gt;hProcess, Str_MODULE_NAME);<span class="comment">//参一的结构体赋值是在上面的函数调用中实现的, 这个结构体是最后一个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟之前的HOOK函数相比</p>
<ul>
<li>省去了hook和unhook</li>
<li>多出了一个 <code>起始地址 + 2</code>的操作</li>
</ul>
<p>注意使用热补丁之前要看看API是否支持热补丁</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LamのCrow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/27/逆向工程核心原理-第33章-隐藏进程 95cea6f6be2c470783b612eb9258314c/">http://example.com/2022/04/27/逆向工程核心原理-第33章-隐藏进程 95cea6f6be2c470783b612eb9258314c/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">LamのCrow</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">逆向工程核心原理</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/05/08/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BC%96%E5%86%99and375a52cb87b22005816fe7a418ec6660/"><i class="fa fa-chevron-left">  </i><span>文件解析器编写</span></a></div><div class="next-post pull-right"><a href="/2022/04/23/StarCTF(%E6%B1%87%E7%BC%96,%20XTEA%E5%8A%A0%E5%AF%86,%20%E5%8F%AF%E9%80%86%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95)%20d2c4611ee19c445694e9c66ea5eb4eb6/"><span>starCTF部分题解</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By LamのCrow</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">追求幸福</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>