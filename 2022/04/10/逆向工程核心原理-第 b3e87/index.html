<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="逆向工程核心原理-28"><meta name="keywords" content="逆向工程核心原理"><meta name="author" content="LamのCrow"><meta name="copyright" content="LamのCrow"><title>逆向工程核心原理-28 | LamのCrow</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC28%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">逆向工程核心原理-第28章-使用汇编语言编写注入代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-1-%E7%9B%AE%E6%A0%87"><span class="toc-number">2.</span> <span class="toc-text">28.1    目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-2-%E6%B1%87%E7%BC%96%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">28.2    汇编编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-3-OD%E7%9A%84%E6%B1%87%E7%BC%96%E5%91%BD%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">28.3    OD的汇编命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#28-3-1-%E7%BC%96%E5%86%99-ThreadProc-%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">28.3.1    编写 ThreadProc() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-3-2-%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">28.3.2    保存文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E9%AA%8C%E4%B8%80%E4%B8%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">检验一下</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-5-%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A0"><span class="toc-number">5.</span> <span class="toc-text">28.5    调试练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#28-5-1-%E8%B0%83%E8%AF%95notepad-exe"><span class="toc-number">5.1.</span> <span class="toc-text">28.5.1    调试notepad.exe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-5-2-%E8%AE%BE%E7%BD%AEOllDbg%E9%80%89%E9%A1%B9"><span class="toc-number">5.2.</span> <span class="toc-text">28.5.2    设置OllDbg选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-5-3-%E8%BF%90%E8%A1%8CCodeInjection2-exe"><span class="toc-number">5.3.</span> <span class="toc-text">28.5.3    运行CodeInjection2.exe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-5-4-%E7%BA%BF%E7%A8%8B%E8%B5%B7%E5%A7%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">5.4.</span> <span class="toc-text">28.5.4    线程起始代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-6-%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">6.</span> <span class="toc-text">28.6    详细分析汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-1-%E7%94%9F%E6%88%90%E6%A0%88%E5%B8%A7"><span class="toc-number">6.1.</span> <span class="toc-text">28.6.1    生成栈帧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-2-THREAD-PARAM-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">6.2.</span> <span class="toc-text">28.6.2    THREAD_PARAM 结构体指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-3-%E2%80%9CUser32-dll%E2%80%9D-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.3.</span> <span class="toc-text">28.6.3    “User32.dll” 字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-4-%E5%8E%8B%E5%85%A5%E2%80%9Duser32-dll%E2%80%9D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%82%E6%95%B0"><span class="toc-number">6.4.</span> <span class="toc-text">28.6.4    压入”user32.dll”字符串参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-5-%E8%B0%83%E7%94%A8LoadLibraryA-%E2%80%9Duser32-dll%E2%80%9D"><span class="toc-number">6.5.</span> <span class="toc-text">28.6.5    调用LoadLibraryA()(”user32.dll”)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-6-%E2%80%9CMessageBoxA%E2%80%9D-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.6.</span> <span class="toc-text">28.6.6    “MessageBoxA” 字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-7-%E8%B0%83%E7%94%A8GetProcAddress-hMod-%E2%80%9CMessageBoxA%E2%80%9D"><span class="toc-number">6.7.</span> <span class="toc-text">28.6.7    调用GetProcAddress(hMod, “MessageBoxA” )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-8-%E5%8E%8B%E5%85%A5MessageBoxA-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0-1-MB-OK"><span class="toc-number">6.8.</span> <span class="toc-text">28.6.8    压入MessageBoxA()函数的参数 1 - MB_OK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-9-%E5%8E%8B%E5%85%A5MessageBoxA-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B02-%E2%80%9CReverseCore%E2%80%9D"><span class="toc-number">6.9.</span> <span class="toc-text">28.6.9    压入MessageBoxA()函数的参数2 - “ReverseCore”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-10-%E5%8E%8B%E5%85%A5MessageBoxA-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0-3-%E2%80%9Cwww-reversecore-com%E2%80%9D"><span class="toc-number">6.10.</span> <span class="toc-text">28.6.10    压入MessageBoxA()函数的参数 3 - “www.reversecore.com”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-11-%E5%8E%8B%E5%85%A5MessageBoxA-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0-4-NULL"><span class="toc-number">6.11.</span> <span class="toc-text">28.6.11    压入MessageBoxA()函数的参数 4 - NULL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-13-%E8%B0%83%E7%94%A8%E4%BA%86MessageBoxA"><span class="toc-number">6.12.</span> <span class="toc-text">28.6.13    调用了MessageBoxA()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-13-%E8%AE%BE%E7%BD%AEThreadProc-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">6.13.</span> <span class="toc-text">28.6.13    设置ThreadProc()函数的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-6-14-%E5%88%A0%E9%99%A4%E6%A0%88%E5%B8%A7%E5%8F%8A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E"><span class="toc-number">6.14.</span> <span class="toc-text">28.6.14    删除栈帧及函数返回</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s4.ax1x.com/2021/12/07/oyWTJA.jpg"></div><div class="author-info__name text-center">LamのCrow</div><div class="author-info__description text-center">欢迎交流!!!</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://space.bilibili.com/202089320">MyBIlibili</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://sma11cc.github.io/">smallcc</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">LamのCrow</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">逆向工程核心原理-28</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-10</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="逆向工程核心原理-第28章-使用汇编语言编写注入代码"><a href="#逆向工程核心原理-第28章-使用汇编语言编写注入代码" class="headerlink" title="逆向工程核心原理-第28章-使用汇编语言编写注入代码"></a>逆向工程核心原理-第28章-使用汇编语言编写注入代码</h1><span id="more"></span>

<h1 id="28-1-目标"><a href="#28-1-目标" class="headerlink" title="28.1    目标"></a>28.1    目标</h1><p>借助OD的汇编功能,  使用汇编语言编写注入代码(ThreadProc()函数),  汇编语言能够生成比C语言更自由,  更灵活的代码(如:  直接访问栈,  寄存器的功能等),  然后将汇编语言编写的ThreadProc()函数注入notepad.exe进程</p>
<h1 id="28-2-汇编编程"><a href="#28-2-汇编编程" class="headerlink" title="28.2    汇编编程"></a>28.2    汇编编程</h1><p>常用开发工具:</p>
<ul>
<li>MASM</li>
<li>TASM</li>
<li>FASM</li>
<li>OD的汇编功能</li>
</ul>
<p>也可以使用OD的汇编功能进行编程,  我们下面将使用OD</p>
<h1 id="28-3-OD的汇编命令"><a href="#28-3-OD的汇编命令" class="headerlink" title="28.3    OD的汇编命令"></a>28.3    OD的汇编命令</h1><p>我们首先使用OD打开asmtest.exe(该程序没有实现任何功能)</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled.png" alt="Untitled"></p>
<p>然后从顶部开始(滚轮直接往上滑),  使用New origin here(此处为新EIP)将EIP设置到最顶端,  快捷键是(Ctrl + Gray*,  Gray就是小键盘,  Gray<em>就是小键盘上的</em>键)</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%201.png" alt="Untitled"></p>
<p>然后在该处进行汇编(快捷键:  Space)</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%202.png" alt="Untitled"></p>
<p>注意,  要取消勾选”使用 NOP 填充”,  这个的功能是当我们输入的代码短于原先代码的时候,  多出来的字节使用NOP来填充</p>
<h2 id="28-3-1-编写-ThreadProc-函数"><a href="#28-3-1-编写-ThreadProc-函数" class="headerlink" title="28.3.1    编写 ThreadProc() 函数"></a>28.3.1    编写 ThreadProc() 函数</h2><p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%203.png" alt="Untitled"></p>
<p>在401033(紧跟在上面汇编的后面)地址处使用Edit选项(Ctrl + E)开始编写字符串</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%204.png" alt="Untitled"></p>
<p>注意后面一定要有一个’\0’</p>
<p>编辑完成后</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%205.png" alt="Untitled"></p>
<p>可以看到OD把这个字符串识别成了代码,  因为这里是代码段,  所以识别为代码非常正常</p>
<p>选中字符串开头后,  执行Analysis命令(快捷键:  Ctrl + A)得到下图</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%206.png" alt="Untitled"></p>
<p>这时在401033地址处可以清晰看到我们的字符串”ReverseCore”</p>
<p>但是上面从401000地址处的代码却分析错误,  我们再使用右键 → 分析 → 从模块中删除分析(Remove analysis from module)</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%207.png" alt="Untitled"></p>
<p>又恢复原来的样子了,  我们接着上面的字符串,  继续编写汇编指令</p>
<p>下面感觉识别错误,  导致开头对不齐,  所以直接使用的编辑</p>
<p>下面是编辑完成后的结果</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%208.png" alt="Untitled"></p>
<h2 id="28-3-2-保存文件"><a href="#28-3-2-保存文件" class="headerlink" title="28.3.2    保存文件"></a>28.3.2    保存文件</h2><p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%209.png" alt="Untitled"></p>
<p>保存为asmtest_patch.exe</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2010.png" alt="Untitled"></p>
<p>使用OD打开asmtest_patch.exe,  再内存窗口中跳转至401000处</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2011.png" alt="Untitled"></p>
<p>选中该区域右键</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2012.png" alt="Untitled"></p>
<p>经过处理以后我们得到了机器码序列</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2013.png" alt="Untitled"></p>
<p>然后就是照着书上的进行编写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span><span class="comment">//注意这个头文件要放在开头, 否则会报架构错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Thread_PARAM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FARPROC pFunc[<span class="number">2</span>];<span class="comment">//参数结构体跟前面的代码注入不同,只包含了两个函数指针</span></span><br><span class="line">&#125; THREAD_PARAM, * PTHREAD_PARAM;<span class="comment">//分别是LoadLibraryA(), GetProcAddress()</span></span><br><span class="line"></span><br><span class="line">BYTE g_InjectionCode[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x8B</span>, <span class="number">0x75</span>, <span class="number">0x08</span>, <span class="number">0x68</span>, <span class="number">0x6C</span>, <span class="number">0x6C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x68</span>, <span class="number">0x33</span>, <span class="number">0x32</span>, <span class="number">0x2E</span>, <span class="number">0x64</span>,</span><br><span class="line"><span class="number">0x68</span>, <span class="number">0x75</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x54</span>, <span class="number">0xFF</span>, <span class="number">0x16</span>, <span class="number">0x68</span>, <span class="number">0x6F</span>, <span class="number">0x78</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x68</span>, <span class="number">0x61</span>, <span class="number">0x67</span>,</span><br><span class="line"><span class="number">0x65</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, <span class="number">0x4D</span>, <span class="number">0x65</span>, <span class="number">0x73</span>, <span class="number">0x73</span>, <span class="number">0x54</span>, <span class="number">0x50</span>, <span class="number">0xFF</span>, <span class="number">0x56</span>, <span class="number">0x04</span>, <span class="number">0x6A</span>, <span class="number">0x00</span>, <span class="number">0xE8</span>, <span class="number">0x0C</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x52</span>, <span class="number">0x65</span>, <span class="number">0x76</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x43</span>, <span class="number">0x6F</span>, <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x00</span>, <span class="number">0xE8</span>,</span><br><span class="line"><span class="number">0x14</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x77</span>, <span class="number">0x77</span>, <span class="number">0x77</span>, <span class="number">0x2E</span>, <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x76</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x63</span>,</span><br><span class="line"><span class="number">0x6F</span>, <span class="number">0x72</span>, <span class="number">0x65</span>, <span class="number">0x2E</span>, <span class="number">0x63</span>, <span class="number">0x6F</span>, <span class="number">0x6D</span>, <span class="number">0x00</span>, <span class="number">0x6A</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0xD0</span>, <span class="number">0x33</span>, <span class="number">0xC0</span>, <span class="number">0x8B</span>, <span class="number">0xE5</span>,</span><br><span class="line"><span class="number">0x5D</span>, <span class="number">0xC3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InjectCode</span><span class="params">(DWORD dwPID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE        hMod = <span class="literal">NULL</span>;             <span class="comment">//模块句柄</span></span><br><span class="line">    THREAD_PARAM   param = &#123; <span class="number">0</span>, &#125;;          <span class="comment">//参数结构体</span></span><br><span class="line">    HANDLE         hProcess = <span class="literal">NULL</span>;         <span class="comment">//进程句柄</span></span><br><span class="line">    HANDLE         hThread = <span class="literal">NULL</span>;          <span class="comment">//线程句柄</span></span><br><span class="line">    LPVOID         pRemoteBuf[<span class="number">2</span>] = &#123; <span class="number">0</span>, &#125;;  <span class="comment">//用于记录目标进程的内存指针</span></span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程过程函数所需要的函数地址, 并存储到参数结构体传入该函数中</span></span><br><span class="line">    param.pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    param.pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">&quot;GetProcAddress&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开进程</span></span><br><span class="line">    <span class="keyword">if</span>(!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未发现该进程PID: err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为数据分配目标进程内存中的内存</span></span><br><span class="line">    <span class="keyword">if</span> (!(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="keyword">sizeof</span>(THREAD_PARAM),</span><br><span class="line">        MEM_COMMIT,</span><br><span class="line">        PAGE_READWRITE))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;在目标内存中分配数据空间失败: err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入代码所需的数据</span></span><br><span class="line">    <span class="keyword">if</span> (!(WriteProcessMemory(hProcess,</span><br><span class="line">        pRemoteBuf[<span class="number">0</span>],</span><br><span class="line">        (LPVOID)&amp;param,</span><br><span class="line">        <span class="keyword">sizeof</span>(THREAD_PARAM),</span><br><span class="line">        <span class="literal">NULL</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入目标进程的内存数据空间时发生错误: err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为代码分配目标进程内存中的内存</span></span><br><span class="line">    <span class="keyword">if</span> (!(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="keyword">sizeof</span>(g_InjectionCode),</span><br><span class="line">        MEM_COMMIT,</span><br><span class="line">        PAGE_EXECUTE_READWRITE))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;在目标内存中分配代码空间失败: err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入代码</span></span><br><span class="line">    <span class="keyword">if</span> (!(WriteProcessMemory(hProcess,</span><br><span class="line">        pRemoteBuf[<span class="number">1</span>],</span><br><span class="line">        (LPVOID)&amp;g_InjectionCode,</span><br><span class="line">        <span class="keyword">sizeof</span>(g_InjectionCode),</span><br><span class="line">        <span class="literal">NULL</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入目标进程的内存代码空间时发生错误: err_code = %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(hThread = CreateRemoteThread(hProcess,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>],</span><br><span class="line">        pRemoteBuf[<span class="number">0</span>],</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建线程失败: err_code = %d&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwPID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n USAGE   : %s pid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dwPID = (DWORD)atol(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (InjectCode(dwPID))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;注入成功\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;注入失败\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书上没有给出主函数,  但是我们可以参考上一章的主函数进行编写,  然后就是书上省略了对异常情况的处理这里我们添加上即可(g_InjectionCode中间有一个数0x14写成了0x15,  汇编代码一注入程序直接关闭了,  找了好久才发现)</p>
<p>然后我们生成exe,  注意要使用Release和x86选项生成的exe才能成功,  试了其他的选项都不行</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2014.png" alt="Untitled"></p>
<h3 id="检验一下"><a href="#检验一下" class="headerlink" title="检验一下"></a>检验一下</h3><p>首先打开notepad.exe</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2015.png" alt="Untitled"></p>
<p>然后使用ProcessExplorer查看其PID</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2016.png" alt="Untitled"></p>
<p>得到PID = 13456</p>
<p>然后在CodeInjection2.exe的文件中以管理员身份打开终端</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2017.png" alt="Untitled"></p>
<p>输入参数运行我们的CodeInjection2.exe</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2018.png" alt="Untitled"></p>
<p>可以看到弹出了我们想要的窗口</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2019.png" alt="Untitled"></p>
<h1 id="28-5-调试练习"><a href="#28-5-调试练习" class="headerlink" title="28.5    调试练习"></a>28.5    调试练习</h1><h2 id="28-5-1-调试notepad-exe"><a href="#28-5-1-调试notepad-exe" class="headerlink" title="28.5.1    调试notepad.exe"></a>28.5.1    调试notepad.exe</h2><p>使用OD工具打开notepad.exe,  F9使其处于运行中状态</p>
<h2 id="28-5-2-设置OllDbg选项"><a href="#28-5-2-设置OllDbg选项" class="headerlink" title="28.5.2    设置OllDbg选项"></a>28.5.2    设置OllDbg选项</h2><p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2020.png" alt="Untitled"></p>
<p>这样当我们的CodeInjection2.exe产生新线程时,  我们就是停下来调试了</p>
<h2 id="28-5-3-运行CodeInjection2-exe"><a href="#28-5-3-运行CodeInjection2-exe" class="headerlink" title="28.5.3    运行CodeInjection2.exe"></a>28.5.3    运行CodeInjection2.exe</h2><p>使用ProcessExplorer查看notepad的进程PID</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2021.png" alt="Untitled"></p>
<p>然后以进程PID作为参数,  运行CodeInjection2.exe</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2022.png" alt="Untitled"></p>
<h2 id="28-5-4-线程起始代码"><a href="#28-5-4-线程起始代码" class="headerlink" title="28.5.4    线程起始代码"></a>28.5.4    线程起始代码</h2><p>当运行CodeInjection2.exe时,  我们来到OD界面,  可以看到停在了我们的线程函数部分</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2023.png" alt="Untitled"></p>
<h1 id="28-6-详细分析汇编指令"><a href="#28-6-详细分析汇编指令" class="headerlink" title="28.6    详细分析汇编指令"></a>28.6    详细分析汇编指令</h1><h2 id="28-6-1-生成栈帧"><a href="#28-6-1-生成栈帧" class="headerlink" title="28.6.1    生成栈帧"></a>28.6.1    生成栈帧</h2><p><code>PUSH    EBP</code></p>
<p><code>MOV     EBP, ESP</code></p>
<p>以上两句为生成栈帧指令</p>
<h2 id="28-6-2-THREAD-PARAM-结构体指针"><a href="#28-6-2-THREAD-PARAM-结构体指针" class="headerlink" title="28.6.2    THREAD_PARAM 结构体指针"></a>28.6.2    THREAD_PARAM 结构体指针</h2><p><code>MOV      ESI, DWORD PTR  [EBP+8]</code></p>
<p>生成栈帧以后,  [EBP + 8] 是传入函数的第一个参数,  这里指THREAD_PARAM结构体指针.  为什么是EBP + 8我们看看栈图即可知道(此时执行完了<code>MOV     EBP, ESP</code>指令)</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2024.png" alt="Untitled"></p>
<p>参数结构体总共有8个字节,  前面四个字节保存的是LoadLibraryA()函数的指针,  后面四个字节保存的是GetProcAddress()函数的指针.</p>
<h2 id="28-6-3-“User32-dll”-字符串"><a href="#28-6-3-“User32-dll”-字符串" class="headerlink" title="28.6.3    “User32.dll” 字符串"></a>28.6.3    “User32.dll” 字符串</h2><p><code>PUSH      6C6C</code>      “\0\0ll”  逆序</p>
<p><code>PUSH      642E3233</code>      “d.23”  逆序</p>
<p><code>PUSH      72657375</code>      “resu”   逆序</p>
<p>上面三行代码将”User32.dll”字符串压入栈中,  这种独特的方法仅用于汇编语言编写的程序,  采用的是逆序的方式压入,  因为栈是从高地址向低地址排列,  且整个数据是以小端排序,  当一整个数据块压入的时候,  会以字节为单位逆序存储,  所以”resu”压入栈中是排列其实是”user”</p>
<p>这样将所需字符串压入栈中的方式,  注入代码时就不需要另外注入数据,  直接使用栈即可.</p>
<p>我们再看看运行完上述语句后的寄存器情况</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2025.png" alt="Untitled"></p>
<p>可以看到此时的ESP就相当于我们的字符串指针</p>
<h2 id="28-6-4-压入”user32-dll”字符串参数"><a href="#28-6-4-压入”user32-dll”字符串参数" class="headerlink" title="28.6.4    压入”user32.dll”字符串参数"></a>28.6.4    压入”user32.dll”字符串参数</h2><p><code>PUSH      ESP</code></p>
<p>LoadLibraryA()API需要一个参数,  用来接收一个字符串的地址,  该字符串为需要加载的DLL文件的名称.  所以我们在上面已经知道了ESP此时相当于”user32.dll”的字符串指针,  所以这里PUSH了ESP来作为下面调用的参数</p>
<h2 id="28-6-5-调用LoadLibraryA-”user32-dll”"><a href="#28-6-5-调用LoadLibraryA-”user32-dll”" class="headerlink" title="28.6.5    调用LoadLibraryA()(”user32.dll”)"></a>28.6.5    调用LoadLibraryA()(”user32.dll”)</h2><p><code>CALL      DWORD PTR [ESI]</code></p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2026.png" alt="Untitled"></p>
<p>前面已经将参数结构体的地址给了ESI,  而ESI所指向的内存则保存着LoadLibraryA的地址,  所以这里调用了LoadLibraryA()函数,  而其参数就是ESP(”user32.dll”的字符串指针)</p>
<p>在调用完成后,  查看其返回值,  就是该模块的句柄</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2027.png" alt="Untitled"></p>
<p>验证一下</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2028.png" alt="Untitled"></p>
<p>可以看到user32.dll的基址就是EAX中的76380000</p>
<h2 id="28-6-6-“MessageBoxA”-字符串"><a href="#28-6-6-“MessageBoxA”-字符串" class="headerlink" title="28.6.6    “MessageBoxA” 字符串"></a>28.6.6    “MessageBoxA” 字符串</h2><p><code>PUSH      41786F          “\0Axo”</code></p>
<p><code>PUSH      42656761          “Bega”</code></p>
<p><code>PUSH      7373654D          “sseM”</code></p>
<p>跟28.6.3同理也是通过把字符串压入栈中,  然后得到了ESP就是该字符串的指针</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2029.png" alt="Untitled"></p>
<h2 id="28-6-7-调用GetProcAddress-hMod-“MessageBoxA”"><a href="#28-6-7-调用GetProcAddress-hMod-“MessageBoxA”" class="headerlink" title="28.6.7    调用GetProcAddress(hMod, “MessageBoxA” )"></a>28.6.7    调用GetProcAddress(hMod, “MessageBoxA” )</h2><p><code>PUSH      ESP</code></p>
<p><code>PUSH      EAX</code></p>
<p><code>CALL      DWORD   PTR   DS : [ESI+4]</code></p>
<p>我们要知道汇编中的参数时逆序要入栈中的,  所以我们先PUSH”MessageBoxA”的指针,  然后再PUSH模块的句柄.  首先,  PUSH”MessageBoxA”的字符串指针,  就是PUSH了ESP;  其次,  我们前面调用了LoadLibraryA()函数的返回值就是hMod模块句柄,  存储在EAX当中,  所以这里PUSH了EAX.</p>
<p>随后调用了[ESI + 4]即是结构体中的第二个成员GetProcAddress()函数的地址.</p>
<p>而它的返回值就是MessageBoxA的函数地址,  存放再了EAX当中</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2030.png" alt="Untitled"></p>
<h2 id="28-6-8-压入MessageBoxA-函数的参数-1-MB-OK"><a href="#28-6-8-压入MessageBoxA-函数的参数-1-MB-OK" class="headerlink" title="28.6.8    压入MessageBoxA()函数的参数 1 - MB_OK"></a>28.6.8    压入MessageBoxA()函数的参数 1 - MB_OK</h2><p>紧接着就开始了调用MessageBoxA()的参数准备,  参数是逆序压入的,  所以首先是压入MB_OK参数</p>
<p><code>PUSH      0</code></p>
<p>压入的时MessageBoxA的第四个参数</p>
<h2 id="28-6-9-压入MessageBoxA-函数的参数2-“ReverseCore”"><a href="#28-6-9-压入MessageBoxA-函数的参数2-“ReverseCore”" class="headerlink" title="28.6.9    压入MessageBoxA()函数的参数2 - “ReverseCore”"></a>28.6.9    压入MessageBoxA()函数的参数2 - “ReverseCore”</h2><p><code>0041002E   E8 0C000000     call    0041003F 00410033    52              push    edx 00410034    65:76 65        jbe     short 0041009c 00410037    72 73           jb      short 004100AC 00410039    65:43           inc     ebx 0041003B    6f              outs    dx, dword ptr [esi] 0041003C    72 65           jb      short 004100A3 0041003E    00E8            add     al, ch</code></p>
<p>很明显,  410033 ~ 41003E地址处为我们的字符串”ReverseCore”,  只不过被识别成了代码.  也就是说,  “ReverseCore”字符串的首地址为410033,  它被用作MessageBoxA()的第三个参数</p>
<p>将字符串作为参数传递给函数前,  要先把字符串的首地址压入栈中</p>
<p>下面,  我们将介绍”使用CALL指令将包含再代码键的字符串数据地址压入栈中”的方法.  </p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2031.png" alt="Untitled"></p>
<p>根据途中的介绍我们可以知道字符串的首地址被压入了栈中,  也就代表着第三个参数被成功压入了栈中,  同时通过CALL指令我们的EIP变成了43003F,  跳过了中间的字符串来到了接下去的代码段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">个人的理解:  这个方法起始就是把CALL指令拆分成了JMP和PUSH两个指令,  首先使用JMP跳转到下一个</span><br><span class="line">指令处,  然后PUSH将需要的数据压入栈中(只不过条件较为苛刻,  只能将紧贴在CALL的下面的数据压入</span><br><span class="line">栈中).</span><br><span class="line"></span><br><span class="line">然后是JMP的一点理解:  在刚开始我有点疑惑的地方是这里CALL的是一个明确的地址<span class="number">43003F</span>, 可是在notepad</span><br><span class="line">中申请的内存是随机,  怎么会跳转到准确的位置呢???</span><br><span class="line">答:  其实之前CSAPP就已经学过了, 这里的CALL在机器码中是根据当前的位置的偏移跳转的,  意思是虽然</span><br><span class="line">我们写入汇编的时候用的绝对的地址,  但是实际CALL的地址一直都是以当前CALL地址为基准点,然后填入</span><br><span class="line">偏移量</span><br><span class="line"><span class="number">0041002</span>E   E8 <span class="number">0</span>C000000     call    <span class="number">0041003F</span></span><br><span class="line"></span><br><span class="line">E8 就是CALL指令的机器码</span><br><span class="line"><span class="number">0</span>C就是偏移量</span><br><span class="line"><span class="number">41002</span>E + <span class="number">0</span>C = 跳转的目标地址</span><br></pre></td></tr></table></figure>

<h2 id="28-6-10-压入MessageBoxA-函数的参数-3-“www-reversecore-com”"><a href="#28-6-10-压入MessageBoxA-函数的参数-3-“www-reversecore-com”" class="headerlink" title="28.6.10    压入MessageBoxA()函数的参数 3 - “www.reversecore.com”"></a>28.6.10    压入MessageBoxA()函数的参数 3 - “<a target="_blank" rel="noopener" href="http://www.reversecore.com”/">www.reversecore.com”</a></h2><p><code>0043003E    00E8            add     al, ch 00430040    14 00           adc     al, 0 00430042    0000            add     byte ptr [eax], al 00430044    77 77           ja      short 004300BD 00430046    77 2E           ja      short 00430076 00430048    72 65           jb      short 004300AF 0043004A    76 65           jbe     short 004300B1 0043004C    72 73           jb      short 004300C1 0043004E    65:636F 72      arpl    word ptr gs:[edi+72], bp 00430052    65              gs: 00430053    2E:636F 6D      arpl    word ptr cs:[edi+6D], bp 00430057    006A 00         add     byte ptr [edx], ch</code></p>
<p>注意,  第一条指令,  由于我的OD分析偏差,  所以跟上面”ReverseCore”结尾的’\0’是连在一起的</p>
<p>实际上的第一条指令机器码为<code>E8  14</code>,意思是<code>CALL     当前位置 + 0x14</code> ,  原理跟上面是一样的 </p>
<h2 id="28-6-11-压入MessageBoxA-函数的参数-4-NULL"><a href="#28-6-11-压入MessageBoxA-函数的参数-4-NULL" class="headerlink" title="28.6.11    压入MessageBoxA()函数的参数 4 - NULL"></a>28.6.11    压入MessageBoxA()函数的参数 4 - NULL</h2><p><code>00430057 006A 00 add byte ptr [edx], ch</code></p>
<p>这里同样是识别错误,  跟上面”<a target="_blank" rel="noopener" href="http://www.reversecore.com”结尾的’/0%E2%80%99%E8%BF%9E%E5%9C%A8%E4%BA%86%E4%B8%80%E8%B5%B7">www.reversecore.com”结尾的’\0’连在了一起</a></p>
<p>实际上的机器码为<code>6A    00</code>, 汇编为: <code>PUSH      00</code>,压入了第一个参数NULL</p>
<h2 id="28-6-13-调用了MessageBoxA"><a href="#28-6-13-调用了MessageBoxA" class="headerlink" title="28.6.13    调用了MessageBoxA()"></a>28.6.13    调用了MessageBoxA()</h2><p><code>0043005A FFD0 call eax</code></p>
<p>我们可能忘记了EAX是从哪里来的(反正我是忘了),  看看汇编窗口</p>
<p><img src="/2022/04/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20b3e87/Untitled%2032.png" alt="Untitled"></p>
<p>你可能感到奇怪的就是中间我们压入那两个字符串的时候不是也调用了CALL吗,  为什么不会影响EAX?</p>
<p>因为使用的这两个CALL指令根本就没有返回,  一直执行到了最后的RETN程序就结束了,  从头到尾都没有返回.</p>
<p>回到正题,  我们可以知道<code>CALL    EAX</code>,  就是调用了MessageBoxA()函数</p>
<h2 id="28-6-13-设置ThreadProc-函数的返回值"><a href="#28-6-13-设置ThreadProc-函数的返回值" class="headerlink" title="28.6.13    设置ThreadProc()函数的返回值"></a>28.6.13    设置ThreadProc()函数的返回值</h2><p><code>0043005C 33C0 xor eax, eax</code></p>
<p>该汇编代码完成之前,  我们还需要做一些准备工作,  XOR指令将线程函数的返回值设置为0</p>
<h2 id="28-6-14-删除栈帧及函数返回"><a href="#28-6-14-删除栈帧及函数返回" class="headerlink" title="28.6.14    删除栈帧及函数返回"></a>28.6.14    删除栈帧及函数返回</h2><p><code>0043005E    8BE5            mov     esp, ebp 00430060    5D              pop     ebp 00430061    C3              retn</code></p>
<p>删除ThradProc()函数一开始生成的栈帧,  然后RETN</p>
<p>至此我们完成了整个调试过程</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LamのCrow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/10/逆向工程核心原理-第 b3e87/">http://example.com/2022/04/10/逆向工程核心原理-第 b3e87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">LamのCrow</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">逆向工程核心原理</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/04/18/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20a5434/"><i class="fa fa-chevron-left">  </i><span>逆向工程核心原理-29</span></a></div><div class="next-post pull-right"><a href="/2022/04/09/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%207317a/"><span>逆向工程核心原理-27</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By LamのCrow</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">追求幸福</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>