<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="逆向工程核心原理-23"><meta name="keywords" content="逆向工程核心原理"><meta name="author" content="LamのCrow"><meta name="copyright" content="LamのCrow"><title>逆向工程核心原理-23 | LamのCrow</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0-DLL%E6%B3%A8%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">逆向工程核心原理-第二十三章-DLL注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-1-DLL%E6%B3%A8%E5%85%A5"><span class="toc-number">2.</span> <span class="toc-text">23.1    DLL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EDllMain-%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">关于DllMain()函数的分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0-dwReason%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">关键参数-dwReason的四种类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-2-DLL%E6%B3%A8%E5%85%A5%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">23.2    DLL注入示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-3-DLL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">23.3    DLL注入的实现方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-4-CreateRemoteThread-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">23.4    CreateRemoteThread()创建远程线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4-1-%E7%BB%83%E4%B9%A0%E7%A4%BA%E4%BE%8Bmyhack-dll"><span class="toc-number">5.1.</span> <span class="toc-text">23.4.1    练习示例myhack.dll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E6%8A%8A%E6%96%87%E4%BB%B6%E9%83%BD%E5%A4%8D%E5%88%B6%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD"><span class="toc-number">5.1.1.</span> <span class="toc-text">首先把文件都复制到一个文件夹中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8Cnotepad-exe"><span class="toc-number">5.1.2.</span> <span class="toc-text">运行notepad.exe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ProcessExplore%E6%9F%A5%E7%9C%8B"><span class="toc-number">5.1.3.</span> <span class="toc-text">使用ProcessExplore查看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8CDebugView"><span class="toc-number">5.1.4.</span> <span class="toc-text">运行DebugView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#myhack-dll%E6%B3%A8%E5%85%A5"><span class="toc-number">5.1.5.</span> <span class="toc-text">myhack.dll注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9ADLL%E6%B3%A8%E5%85%A5%E6%88%90%E5%8A%9F"><span class="toc-number">5.1.6.</span> <span class="toc-text">确定DLL注入成功</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%84%B6%E5%90%8E%E6%9F%A5%E7%9C%8BProcessExplore"><span class="toc-number">5.1.7.</span> <span class="toc-text">然后查看ProcessExplore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E7%A1%AE%E8%AE%A4"><span class="toc-number">5.1.8.</span> <span class="toc-text">结果确认</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4-2-%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">5.2.</span> <span class="toc-text">23.4.2    分析示例源代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#myhack-cpp"><span class="toc-number">5.2.1.</span> <span class="toc-text">myhack.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InjectDll-cpp"><span class="toc-number">5.2.2.</span> <span class="toc-text">InjectDll.cpp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenProcess"><span class="toc-number">6.</span> <span class="toc-text">OpenProcess()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-1"><span class="toc-number">6.2.</span> <span class="toc-text">参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dwDesiredAccess"><span class="toc-number">6.2.1.</span> <span class="toc-text">dwDesiredAccess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bInheritHandle"><span class="toc-number">6.2.2.</span> <span class="toc-text">bInheritHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dwProcessld"><span class="toc-number">6.2.3.</span> <span class="toc-text">dwProcessld</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">6.3.</span> <span class="toc-text">返回值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VirtualAllocEx"><span class="toc-number">7.</span> <span class="toc-text">VirtualAllocEx</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-2"><span class="toc-number">7.2.</span> <span class="toc-text">参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hProcess"><span class="toc-number">7.2.1.</span> <span class="toc-text">hProcess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lpAddress"><span class="toc-number">7.2.2.</span> <span class="toc-text">lpAddress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dwSize"><span class="toc-number">7.2.3.</span> <span class="toc-text">dwSize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flAllocationType"><span class="toc-number">7.2.4.</span> <span class="toc-text">flAllocationType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flProtect"><span class="toc-number">7.2.5.</span> <span class="toc-text">flProtect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="toc-number">7.3.</span> <span class="toc-text">返回值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WriteProcessMemory"><span class="toc-number">8.</span> <span class="toc-text">WriteProcessMemory</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-1"><span class="toc-number">8.1.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number">8.2.</span> <span class="toc-text">返回值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CreateRemoteThread-%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">CreateRemoteThread,  关键函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-2"><span class="toc-number">9.1.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-3"><span class="toc-number">9.2.</span> <span class="toc-text">参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hProcess-1"><span class="toc-number">9.2.1.</span> <span class="toc-text">hProcess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lpThreadAttributes"><span class="toc-number">9.2.2.</span> <span class="toc-text">lpThreadAttributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dwStackSize"><span class="toc-number">9.2.3.</span> <span class="toc-text">dwStackSize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lpStartAddress"><span class="toc-number">9.2.4.</span> <span class="toc-text">lpStartAddress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lpParameter"><span class="toc-number">9.2.5.</span> <span class="toc-text">lpParameter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dwCreationFlags"><span class="toc-number">9.2.6.</span> <span class="toc-text">dwCreationFlags</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lpThreadId"><span class="toc-number">9.2.7.</span> <span class="toc-text">lpThreadId</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="toc-number">9.3.</span> <span class="toc-text">返回值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%8D%E5%9B%9E%E6%9D%A5%E5%88%86%E6%9E%90InjectDll-exe"><span class="toc-number">10.</span> <span class="toc-text">再回来分析InjectDll.exe</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CreateRemoteThread-%E5%AE%9E%E7%8E%B0DLL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">10.1.</span> <span class="toc-text">CreateRemoteThread()实现DLL注入的原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-4-3-%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">23.4.3    调试方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AppInit-DLLs%E6%B3%A8%E5%85%A5"><span class="toc-number">12.</span> <span class="toc-text">AppInit_DLLs注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">12.1.</span> <span class="toc-text">源代码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C"><span class="toc-number">12.2.</span> <span class="toc-text">实际操作</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s4.ax1x.com/2021/12/07/oyWTJA.jpg"></div><div class="author-info__name text-center">LamのCrow</div><div class="author-info__description text-center">欢迎交流!!!</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://space.bilibili.com/202089320">MyBIlibili</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://sma11cc.github.io/">smallcc</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">LamのCrow</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">逆向工程核心原理-23</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-05</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="逆向工程核心原理-第二十三章-DLL注入"><a href="#逆向工程核心原理-第二十三章-DLL注入" class="headerlink" title="逆向工程核心原理-第二十三章-DLL注入"></a>逆向工程核心原理-第二十三章-DLL注入</h1><span id="more"></span>

<p>里面函数分析部分很多的内容都参考了SYJ学长的看雪博客:  <a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-266901.htm">https://bbs.pediy.com/thread-266901.htm</a></p>
<h1 id="23-1-DLL注入"><a href="#23-1-DLL注入" class="headerlink" title="23.1    DLL注入"></a>23.1    DLL注入</h1><p>DLL注入是指向运行中的其他进程强制插入特定的DLL文件.</p>
<p>从技术细节来说,  DLL注入命令其他进程自行调用LoadLibrary()API,  加载(Loading)用户指定的DLL文件.</p>
<p>DLL注入与一般DLL加载的区别在于,  加载的目标进程是其自身或其他进程.</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled.png" alt="Untitled"></p>
<p>如上图所示,  myhack.dll被注入到notepad.exe中,  关键在于myhack.dll拥有与其他DLL一样的权限,  比如访问notepad进程内存,  这样就可以做任何想做的事情了.</p>
<h2 id="关于DllMain-函数的分析"><a href="#关于DllMain-函数的分析" class="headerlink" title="关于DllMain()函数的分析"></a>关于DllMain()函数的分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE instDLL, DWORD dwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(weReason)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">				<span class="comment">//添加像执行的代码</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> TRUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>instDLL      指向自身的句柄</li>
<li>dwReason        调用的原因</li>
<li>lpvReserved        隐式加载和显式加载</li>
</ul>
<h3 id="关键参数-dwReason的四种类型"><a href="#关键参数-dwReason的四种类型" class="headerlink" title="关键参数-dwReason的四种类型"></a>关键参数-dwReason的四种类型</h3><ul>
<li>DLL_PROCESS_ATTACH(进程映射(附加)):  当一个程序需要调用一个DLL中的函数,  首先要把DLL文件映射到进程的地址空间(前面钩子处理函数KeyboardProc()就是这样).  要把一个DLL文件映射到进程的地址空间,  有两种方法:  静态链接和动态链接的LoadLibrary或LoadLibraryEx.       同时,  当一个DLL文件被映射到进程的地址空间时,  系统会调用该DLL的DllMain函数,  此时dwReason的值为DLL_PROCESS_ATTACH,  这种调用<strong>只发生在第一次映射时</strong>,  如果同一个进程后来为已经映射进来的DLL再次调用LoadLibrary或LoadLibraryEx,  操作系统只会增加DLL的使用次数,  不会再用DLL_PROCESS_ATTACH调用DLL的DllMain函数.不同进程用LoadLibrary同一个DLL时,  每个进程的第一次映射都会用DLL_PROCESS_ATTACH调用DllMain函数.  总而言之,  以DLL_PROCESS_ATTACH调用DllMain只发生在一个进程第一次调用该DLL时发生</li>
<li>DLL_PROCESS_DETACH(进程卸载):  当DLL从进程的地址空间中<strong>被解除映射</strong>时,  系统使用参数DLL_PROCESS_DETACH调用DllMain(),  使用该值的DllMain执行的是DLL的清理工作.  DLL被解除映射的两种情况:  1.  FreeLibrary解除DLL映射  2.  进程结束而解除DLL映射.  <strong>注意</strong>:  当使用DLL_PROCESS_ATTACH调用DLL的DllMain时,  如果返回FALSE,  说明初始化失败,  系统会调用DLL_PROCESS_DETACH再次调用DllMain进行清理,  因此,  必须保证清理那些没有成功初始化的东西(会占用资源)</li>
<li>DLL_THREAD_ATTACH(线程映射):  当进程创建一个线程的时候,  系统查看当前进程地址空间中的所有DLL文件映像,  并用DLL_THREAD_ATTACH调用DLL的DllMain函数,  新创建的线程负责执行这次DLL的DllMain函数,  只有所有的DLL都处理完这一个通知后,  系统才允许进程开始执行它的线程函数.  注意跟DLL_PROCESS_ATTACH的区别,  DLL_PROCESS_ATTACH只执行一次,  但是DLL_PROCESS_ATTACH只要有一个新线程在该进程中创建都会执行,  哪怕在线程中建立线程也是一样的.</li>
<li>DLL_THREAD_DETACH(线程卸载):   如果线程调用ExitThread来结束线程(线程函数返回时,  系统也会自动调用ExitThread),  系统查看当前映射到进程空间中的所有DLL文件映像,  并用DLL_THREAD_DETACH来调用DllMain函数,  并通知所有的DLL去执行线程级的清理工作.</li>
</ul>
<h1 id="23-2-DLL注入示例"><a href="#23-2-DLL注入示例" class="headerlink" title="23.2    DLL注入示例"></a>23.2    DLL注入示例</h1><p>使用LoadLibrary()API加载某个DLL时,  该DLL中的DllMain()函数就会调用执行.</p>
<p>DLL注入的工作原理就是从外部促使目标进程调用LoadLibrary()API,  所以会强制调用执行DLL的DLLMain()函数.</p>
<ul>
<li>改善功能和修复Bug</li>
<li>消息钩取</li>
<li>API钩取</li>
<li>其他应用程序</li>
<li>恶意代码</li>
</ul>
<h1 id="23-3-DLL注入的实现方法"><a href="#23-3-DLL注入的实现方法" class="headerlink" title="23.3    DLL注入的实现方法"></a>23.3    DLL注入的实现方法</h1><p>三种方法:</p>
<ul>
<li>创建远程线程(CreateRemoteThread()API)</li>
<li>使用注册表(AppInit_DLLs值)</li>
<li>消息钩取(SetWindowsHookEx()API)</li>
</ul>
<h1 id="23-4-CreateRemoteThread-创建远程线程"><a href="#23-4-CreateRemoteThread-创建远程线程" class="headerlink" title="23.4    CreateRemoteThread()创建远程线程"></a>23.4    CreateRemoteThread()创建远程线程</h1><h2 id="23-4-1-练习示例myhack-dll"><a href="#23-4-1-练习示例myhack-dll" class="headerlink" title="23.4.1    练习示例myhack.dll"></a>23.4.1    练习示例myhack.dll</h2><p>过程时将myhack.dll注入notepad.exe进程,  被注入的没有hack.dll用来联网并下载一个html文件.</p>
<h3 id="首先把文件都复制到一个文件夹中"><a href="#首先把文件都复制到一个文件夹中" class="headerlink" title="首先把文件都复制到一个文件夹中"></a>首先把文件都复制到一个文件夹中</h3><p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%201.png" alt="Untitled"></p>
<h3 id="运行notepad-exe"><a href="#运行notepad-exe" class="headerlink" title="运行notepad.exe"></a>运行notepad.exe</h3><p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%202.png" alt="Untitled"></p>
<h3 id="使用ProcessExplore查看"><a href="#使用ProcessExplore查看" class="headerlink" title="使用ProcessExplore查看"></a>使用ProcessExplore查看</h3><p>可以看到notepad的PID为2008</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%203.png" alt="Untitled"></p>
<h3 id="运行DebugView"><a href="#运行DebugView" class="headerlink" title="运行DebugView"></a>运行DebugView</h3><p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%204.png" alt="Untitled"></p>
<h3 id="myhack-dll注入"><a href="#myhack-dll注入" class="headerlink" title="myhack.dll注入"></a>myhack.dll注入</h3><p>InjectDll.exe用来向目标进程注入DLL文件的实用小程序.打开命令行输入相应参数即可运行InjectDll.exe</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%205.png" alt="Untitled"></p>
<h3 id="确定DLL注入成功"><a href="#确定DLL注入成功" class="headerlink" title="确定DLL注入成功"></a>确定DLL注入成功</h3><p>我们查看debugview</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%206.png" alt="Untitled"></p>
<h3 id="然后查看ProcessExplore"><a href="#然后查看ProcessExplore" class="headerlink" title="然后查看ProcessExplore"></a>然后查看ProcessExplore</h3><p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%207.png" alt="Untitled"></p>
<p>可以看到myhack.dll已经注入到了notepad.exe中</p>
<h3 id="结果确认"><a href="#结果确认" class="headerlink" title="结果确认"></a>结果确认</h3><p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%208.png" alt="Untitled"></p>
<p>可以看到网站已经下载</p>
<h2 id="23-4-2-分析示例源代码"><a href="#23-4-2-分析示例源代码" class="headerlink" title="23.4.2    分析示例源代码"></a>23.4.2    分析示例源代码</h2><h3 id="myhack-cpp"><a href="#myhack-cpp" class="headerlink" title="myhack.cpp"></a>myhack.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span>    <span class="comment">//导入宽字节头文件</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;urlmon.lib&quot;</span>)   <span class="comment">//将静态库链接到项目中</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_URL (<span class="meta-string">L&quot;http://www.naver.com/index.html&quot;</span>)  <span class="comment">//define我们要保存的网页</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_FILE_NAME (<span class="meta-string">L&quot;index.html&quot;</span>) <span class="comment">//define我们保存的网页的文件名</span></span></span><br><span class="line"> </span><br><span class="line">HMODULE g_hMod = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span> <span class="comment">//LPVOID是一个没有类型的指针,可以将LPVOID类型的变量赋值给任意类型的指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR szPath[_MAX_PATH] = &#123; <span class="number">0</span>, &#125;;    <span class="comment">//定义一个数组来储存路径</span></span><br><span class="line">    <span class="keyword">if</span> (!GetModuleFileName(g_hMod, szPath, MAX_PATH))<span class="comment">//这里就是获取当前模块的路径,因为该模块跟我们要存储html文件的路径是一样的, 所以我们在这里用这个函数获取前面的路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    TCHAR *p = _tcsrchr(szPath, <span class="string">&#x27;\\&#x27;</span>);      <span class="comment">//在szPath储存的路径中从右到左寻找字符\\并返回字符串指针</span></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    _tcscpy_s(p + <span class="number">1</span>, _MAX_PATH, DEF_FILE_NAME);  <span class="comment">//生成文件保存的路径, 将index.html保存在szPath路径最后的&#x27;\&#x27;字符之后</span></span><br><span class="line">    URLDownloadToFile(<span class="literal">NULL</span>, DEF_URL, szPath, <span class="number">0</span>, <span class="literal">NULL</span>); <span class="comment">//下载文件保存到szPath所描述的文件中</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//hinstDLL: 指向自身的句柄</span></span><br><span class="line">    HANDLE hTread = <span class="literal">NULL</span>;  <span class="comment">//定义一个通用句柄</span></span><br><span class="line">    g_hMod = (HMODULE)hinstDLL;     <span class="comment">//将dll自身的句柄赋给g_hMod</span></span><br><span class="line">    <span class="keyword">switch</span>(fdwReason)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:<span class="comment">//这里就是首次加载DLL是运行的标签</span></span><br><span class="line">        OutputDebugString(<span class="string">L&quot;myhack.dll Injection!!!&quot;</span>);     <span class="comment">//调用OutputDebugString函数和调试器交流，并在调试器中输出字符串</span></span><br><span class="line">        hTread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);<span class="comment">//创建一个线程来执行ThreadProc()从而在这个Work文件夹中下载index.html</span></span><br><span class="line">        CloseHandle(hTread);<span class="comment">//再清除这个线程</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InjectDll-cpp"><a href="#InjectDll-cpp" class="headerlink" title="InjectDll.cpp"></a>InjectDll.cpp</h3><p>用到的函数和指针分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tchar.h</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath) //L是长指针,P代表指针的意思,C代表const常量的意思,T代表通用类型的意思</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    HANDLE hProcess = NULL, hThread = NULL;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    HMODULE hMod = NULL;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    LPVOID pRemoteBuf = NULL;     //void型的长指针</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //确定路径需要占用的缓冲区大小,  _tcslen测量字符串的长度,然后加上结尾的空字符,再乘sizeof(TCHAR)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    LPTHREAD_START_ROUTINE pThreadProc; //LPTHREAD_START_ROUTINE等价于typedef DWORD (__stdcall *LPTHREAD_START_ROUTINE) (LPVOID lpThreadParameter);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //OpenProcess函数获取目标进程句柄（PROCESS_ALL_ACCESS权限）</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        _tprintf(L&quot;</span>OpenProcess(%d) failed!!! [%d]\n<span class="meta-string">&quot;, dwPID, GetLastError()); //如果打开失败,使用GetLastError()来获取错误信息</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        return FALSE;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //使用VirtualAllocEx函数在目标进程中分配内存，大小为Dll路径的大小</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //VirtualAllocEx函数返回的是hProcess指向的目标进程的分配所得缓冲区的内存的首地址</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); //pRemoteBuf就是分配的内存的首地址</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //将myhack.dll路径 (&quot;</span>c:\\myhack.dll<span class="meta-string">&quot;)写入目标进程中分配到的内存</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">          hMod = GetModuleHandle(L&quot;</span>kernel32.dll<span class="meta-string">&quot;); //直接获取kernel32.dll的句柄</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, &quot;</span>LoadLibraryW<span class="meta-string">&quot;);//为之前定义的函数指针赋成kernel32.dll中LoadLibraryW函数的地址</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL); //hThread为新线程句柄</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    WaitForSingleObject(hThread, INFINITE);       </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    //关闭句柄</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    CloseHandle(hThread);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    CloseHandle(hProcess);</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    return TRUE;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">int _tmain(int argc, TCHAR *argv[])</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    if( argc != 3)    //检测doc输入的参数个数是否是3个</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        _tprintf(L&quot;</span>USAGE : %s <span class="meta-string">&lt;pid&gt;</span> <span class="meta-string">&lt;dll_path&gt;</span>\n<span class="meta-string">&quot;, argv[0]); //printf的通用类型</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        return 1;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    // change privilege</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    if( !SetPrivilege(SE_DEBUG_NAME, TRUE) )     //提升权限,以便kill进程等操作</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        return 1;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"> </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    // inject dll</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">    if( InjectDll((DWORD)_tstol(argv[1]), argv[2]) )  //argv[1]为进程的pid, argv[2]为dll的路径</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        _tprintf(L&quot;</span>InjectDll(\<span class="meta-string">&quot;%s\&quot;) success!!!\n&quot;</span>, argv[2]);</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _tprintf(<span class="string">L&quot;InjectDll(\&quot;%s\&quot;) failed!!!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面逐个分析API</p>
<h1 id="OpenProcess"><a href="#OpenProcess" class="headerlink" title="OpenProcess()"></a>OpenProcess()</h1><p>用来打开一个**已经存在的(注意这个条件)**进程对象,  并返回进程的句柄</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwDesiredAccess, <span class="comment">//渴望得到的访问权限（标志）</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br><span class="line"><span class="params"><span class="function">BOOL bInheritHandle, <span class="comment">// 是否继承句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwProcessId<span class="comment">// 进程标示符</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><h3 id="dwDesiredAccess"><a href="#dwDesiredAccess" class="headerlink" title="dwDesiredAccess"></a><strong>dwDesiredAccess</strong></h3><ul>
<li>PROCESS_ALL_ACCESS：获取所有权限</li>
<li>PROCESS_CREATE_PROCESS：创建进程</li>
<li>PROCESS_CREATE_THREAD：创建线程</li>
<li>PROCESS_DUP_HANDLE：使用DuplicateHandle()函数复制一个新句柄</li>
<li>PROCESS_QUERY_INFORMATION：获取进程的令牌、退出码和优先级等信息</li>
<li>PROCESS_QUERY_LIMITED_INFORMATION：获取进程特定的某个信息</li>
<li>PROCESS_SET_INFORMATION：设置进程的某种信息</li>
<li>PROCESS_SET_QUOTA：使用SetProcessWorkingSetSize函数设置内存限制</li>
<li>PROCESS_SUSPEND_RESUME：暂停或者恢复一个进程</li>
<li>PROCESS_TERMINATE：使用Terminate函数终止进程</li>
<li>PROCESS_VM_OPERATION：在进程的地址空间执行操作</li>
<li>PROCESS_VM_READ：使用ReadProcessMemory函数在进程中读取内存</li>
<li>PROCESS_VM_WRITE：使用WriteProcessMemory函数在进程中写入内存</li>
<li>SYNCHRONIZE：使用wait函数等待进程终止</li>
</ul>
<h3 id="bInheritHandle"><a href="#bInheritHandle" class="headerlink" title="bInheritHandle"></a><strong>bInheritHandle</strong></h3><ul>
<li>TRUE</li>
<li>FALSE</li>
</ul>
<h3 id="dwProcessld"><a href="#dwProcessld" class="headerlink" title="dwProcessld"></a>dwProcessld</h3><ul>
<li>已存在进程的PID</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>成功,   则返回指定进程的句柄</li>
<li>失败,   则返回NULL,  并可用GetLastError获取错误代码</li>
</ul>
<h1 id="VirtualAllocEx"><a href="#VirtualAllocEx" class="headerlink" title="VirtualAllocEx"></a><strong><strong>VirtualAllocEx</strong></strong></h1><p>在指定进程(注意是指定,  在这里我们所指定的就是notepad的内存区域,  而不是我们运行的Injectdll)的虚拟空间保留或提交内存区域,  除非指定MEM_RESET参数,  否则将该内存区域初始化为0</p>
<h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAllocEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE hProcess,<span class="comment">//即将申请内存的进程句柄, 这里是notepad的进程句柄, 是用OpenProcess()获得的</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpAddress,<span class="comment">//保留页面的内存地址, 一般设为NULL让系统自动分配</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T dwSize,<span class="comment">//想分配的内存大小, 以字节为单位, 实际分配的内存大小是业内存大小的整数倍</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br><span class="line"><span class="params"><span class="function">DWORD flAllocationType,<span class="comment">//分配方式</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br><span class="line"><span class="params"><span class="function">DWORD flProtect<span class="comment">//设置该内存保护属性</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><h3 id="hProcess"><a href="#hProcess" class="headerlink" title="hProcess"></a>hProcess</h3><ul>
<li>申请内存所在的句柄</li>
</ul>
<h3 id="lpAddress"><a href="#lpAddress" class="headerlink" title="lpAddress"></a><strong>lpAddress</strong></h3><ul>
<li>保留页面的内存地址, 一般设为NULL让系统自动分配</li>
</ul>
<h3 id="dwSize"><a href="#dwSize" class="headerlink" title="dwSize"></a><strong>dwSize</strong></h3><ul>
<li>想分配的内存大小, 以字节为单位, 实际分配的内存大小是业内存大小的整数倍</li>
</ul>
<h3 id="flAllocationType"><a href="#flAllocationType" class="headerlink" title="flAllocationType"></a><strong>flAllocationType</strong></h3><ul>
<li><strong>MEM_COMMIT：为特定的页面区域分配内存中或磁盘的页面文件中的物理存储</strong></li>
<li>MEM_PHYSICAL ：分配物理内存（仅用于地址窗口扩展内存</li>
<li>MEM_RESERVE：保留进程的虚拟地址空间，而不分配任何物理存储。保留页面可通过继续调用VirtualAlloc（）而被占用</li>
<li>MEM_RESET ：指明在内存中由参数lpAddress和dwSize指定的数据无效</li>
<li>MEM_TOP_DOWN：在尽可能高的地址上分配内存（Windows 98忽略此标志）</li>
<li>MEM_WRITE_WATCH：必须与MEM_RESERVE一起指定，使系统跟踪那些被写入分配区域的页面（仅针对Windows 98）</li>
</ul>
<h3 id="flProtect"><a href="#flProtect" class="headerlink" title="flProtect"></a><strong>flProtect</strong></h3><ul>
<li>PAGE_READONLY： 该区域为只读。如果应用程序试图访问区域中的页的时候，将会被拒绝访问</li>
<li>PAGE_READWRITE: 区域可被应用程序读写</li>
<li>PAGE_EXECUTE： 区域包含可被系统执行的代码。试图读写该区域的操作将被拒绝。</li>
<li>PAGE_EXECUTE_READ ：区域包含可执行代码，应用程序可以读该区域</li>
<li>PAGE_EXECUTE_READWRITE： 区域包含可执行代码，应用程序可以读写该区域。</li>
<li>PAGE_GUARD： 区域第一次被访问时进入一个STATUS_GUARD_PAGE异常，这个标志要和其他保护标志合并使用，表明区域被第一次访问的权限</li>
<li>PAGE_NOACCESS： 任何访问该区域的操作将被拒绝</li>
<li>PAGE_NOCACHE： RAM中的页映射到该区域时将不会被微处理器缓存（cached)</li>
</ul>
<h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>成功,  则返回分配的内存的首地址</li>
<li>是被,  则返回NULL</li>
</ul>
<h1 id="WriteProcessMemory"><a href="#WriteProcessMemory" class="headerlink" title="WriteProcessMemory"></a><strong><strong>WriteProcessMemory</strong></strong></h1><p>将数据写入内存的函数,  但是前提是这段内存是可写的,  这就是前面的VirtualAllocEx的参数flProtect的值PAGE_READWRITE的作用了,  它使得我们分配的那段内存是可读可写的.</p>
<h2 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE hProcess,<span class="comment">//该内存所在的进程的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpBaseAddress,<span class="comment">//要**被写入**的内存首地址</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpBuffer,<span class="comment">//**要写入**的数据的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">DWORD nSize,<span class="comment">//要写入的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">LPDWORD lpNumberOfBytesWritten<span class="comment">//实际数据的长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>成功,  则返回一个非零值</li>
<li>失败,  则返回0,  可以用GetLastError获取跟多错误详细信息</li>
</ul>
<h1 id="CreateRemoteThread-关键函数"><a href="#CreateRemoteThread-关键函数" class="headerlink" title="CreateRemoteThread,  关键函数"></a><strong><strong>CreateRemoteThread,  关键函数</strong></strong></h1><p>创建一个在<strong>其他进程</strong>(注意是在其他进程中)地址空间中<strong>运行</strong>(注意是运行的)的线程(即远程线程)</p>
<h2 id="原型-2"><a href="#原型-2" class="headerlink" title="原型"></a>原型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__in HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__in LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__in SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__in LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__in LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__in DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">__outSECURITY_ATTRIBUTES</span></span></span><br></pre></td></tr></table></figure>

<h2 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h2><h3 id="hProcess-1"><a href="#hProcess-1" class="headerlink" title="hProcess"></a>hProcess</h3><p>创建的<strong>要执行的</strong>线程所属的进程的句柄</p>
<h3 id="lpThreadAttributes"><a href="#lpThreadAttributes" class="headerlink" title="lpThreadAttributes"></a><strong>lpThreadAttributes</strong></h3><p>一个指向SECURITY_ATTRIBUTES结构的指针, 该结构指定了线程的安全属性.</p>
<h3 id="dwStackSize"><a href="#dwStackSize" class="headerlink" title="dwStackSize"></a><strong>dwStackSize</strong></h3><p>线程栈初始大小,以字节为单位,如果该值设为0,那么使用系统默认大小.</p>
<h3 id="lpStartAddress"><a href="#lpStartAddress" class="headerlink" title="lpStartAddress"></a><strong>lpStartAddress</strong></h3><p>在远程进程的地址空间中,  该线程的线程函数的起始地址</p>
<p>在这里传入的是LoadLibraryW库函数的地址</p>
<h3 id="lpParameter"><a href="#lpParameter" class="headerlink" title="lpParameter"></a><strong>lpParameter</strong></h3><p>传给线程函数的参数</p>
<p>在这里传入的是myhack.dll的路径</p>
<h3 id="dwCreationFlags"><a href="#dwCreationFlags" class="headerlink" title="dwCreationFlags"></a><strong>dwCreationFlags</strong></h3><p>线程的创建表示</p>
<h3 id="lpThreadId"><a href="#lpThreadId" class="headerlink" title="lpThreadId"></a><strong>lpThreadId</strong></h3><p>指向所创建线程ID的指针,  如果创建失败,  该参数为NULL</p>
<h2 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h2><ul>
<li>成功,  则返回新线程的句柄</li>
<li>失败,  则返回NULL</li>
</ul>
<h1 id="再回来分析InjectDll-exe"><a href="#再回来分析InjectDll-exe" class="headerlink" title="再回来分析InjectDll.exe"></a>再回来分析InjectDll.exe</h1><ul>
<li>首先获取目标进程句柄,  使用OpenProcess()实现</li>
<li>在notepad的地址空间中分配内存来存储myhack.dll的路径,  通过VirtualAllocEx()实现</li>
<li>将myhack.dll的路径写入notepad的内存空间中并获取该地址,  通过WriteProcessMemory实现</li>
<li>获取LoadLibraryW的地址,  由于DLL共享所以可以直接使用GetProcAddress获得</li>
<li>使用CreateRemoteThread()在notepad中创建一个进程调用LoadLibraryW()从而加载myhack.dll</li>
<li>在myhack.dll中执行了DllMain函数,  在其中调用ThreadProc()(及线程过程函数)下载了网页</li>
</ul>
<h2 id="CreateRemoteThread-实现DLL注入的原理"><a href="#CreateRemoteThread-实现DLL注入的原理" class="headerlink" title="CreateRemoteThread()实现DLL注入的原理"></a>CreateRemoteThread()实现DLL注入的原理</h2><p>首先我们一定一定要知道的是InjectDll.exe调用了CreateRemoteThread(),  而CreateRemoteThread()作用的进程却是notepad.exe</p>
<p>而CreateRemoteThread()对notepad.exe做了什么呢,  就是在notepad.exe中创建了一个线程,  且这个线程调用了LoadLibraryW()这个API,  而这个LoadLibraryW()加载的就是myhack.dll.  在这里停下,  DLL就是这样注入到了notepad当中.</p>
<p>再具体一点就是,  我们先来看看具体的Inject DLL.cpp源代码</p>
<p><code>hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);</code></p>
<p>注意第四个参数和第五个参数</p>
<ul>
<li>pThreadProc,  这个参数是线程函数的起始地址,  意即线程开始时在那个函数那里执行,  我们传入的是LoadLibraryW()函数的地址,  所以该线程会执行该函数在notepad.exe中注入某个DLL,  但是我们现在不知道要注入的是哪个DLL,  所以还需要给LoadLibraryW()一个参数</li>
<li>pRemoteBuf,  这个参数就是为了弥补上面的空缺,  告诉线程中执行的LoadLibraryW()要注入哪个DLL,  在这个实例中我们给的值是myhack.dll的路径,  所以LoadLibraryW()会注入myhack.dll,  并执行其DllMain(),  剩下的事情就跟消息钩子一样了.</li>
</ul>
<h1 id="23-4-3-调试方法"><a href="#23-4-3-调试方法" class="headerlink" title="23.4.3    调试方法"></a>23.4.3    调试方法</h1><p>首先打开notepad.exe</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%209.png" alt="Untitled"></p>
<p>然后打开OD,  使用附加功能,  将OD附加到notepad上</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%2010.png" alt="Untitled"></p>
<p>然后就可以调试notepad.exe了</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%2011.png" alt="Untitled"></p>
<p>然后我们设置选项,  使得调试会在DLL注入时在DLL的EP处暂停</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%2012.png" alt="Untitled"></p>
<h1 id="AppInit-DLLs注入"><a href="#AppInit-DLLs注入" class="headerlink" title="AppInit_DLLs注入"></a>AppInit_DLLs注入</h1><p>该方法使用的是注册表修改,  修改AppInit_DLLs 和 LoadAppInit_DLLs,  使得每个加载了user32.dll的进程都会加载我们添加的DLL,  从而实现DLL注入</p>
<h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myhack.cpp. 作用是以隐藏模式运行IE，连接到指定网站</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tchar.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_CMD  <span class="meta-string">L&quot;c:\\Program Files\\Internet Explorer\\iexplore.exe&quot;</span>  <span class="comment">//定义要打开的浏览器的路径</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_ADDR <span class="meta-string">L&quot;http://www.naver.com&quot;</span>  <span class="comment">//要打开的网址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_DST_PROC <span class="meta-string">L&quot;notepad.exe&quot;</span>       <span class="comment">//要用于比较的进程的名称</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR szCmd[MAX_PATH]  = &#123;<span class="number">0</span>,&#125;;<span class="comment">//我们控制台的输入</span></span><br><span class="line">    TCHAR szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;<span class="comment">//DLL文件路径</span></span><br><span class="line">    TCHAR *p = <span class="literal">NULL</span>;</span><br><span class="line">    STARTUPINFO si = &#123;<span class="number">0</span>,&#125;;    <span class="comment">//定义一个STARTUPINFO类型的结构体,用于指定新进程的主窗口特性的一个结构</span></span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>,&#125;; <span class="comment">//定义一个PROCESS_INFORMATION(进程信息)类型的结构体,</span></span><br><span class="line"> </span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(STARTUPINFO);     <span class="comment">//包含STARTUPINFO结构中的字节数</span></span><br><span class="line">    si.dwFlags = STARTF_USESHOWWINDOW; <span class="comment">//使用(感觉用激活更好些)该结构体的wShowWindow成员</span></span><br><span class="line">    si.wShowWindow = SW_HIDE; <span class="comment">//以隐藏方式打开窗口,即隐藏, 并且任务栏也没有最小化图标</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span>( fdwReason )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH :<span class="comment">//DLL首次载入时执行的语句</span></span><br><span class="line">        <span class="keyword">if</span>( !GetModuleFileName( <span class="literal">NULL</span>, szPath, MAX_PATH ) ) <span class="comment">//获取该dll加载到的进程的全路径</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( !(p = _tcsrchr(szPath, <span class="string">&#x27;\\&#x27;</span>)) ) <span class="comment">//获取&quot;\\&quot;字符之后的进程名指针</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( _tcsicmp(p+<span class="number">1</span>, DEF_DST_PROC) )  <span class="comment">//比较进程是否是指定的进程notepad.exe</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        wsprintf(szCmd, <span class="string">L&quot;%s %s&quot;</span>, DEF_CMD, DEF_ADDR);  <span class="comment">//将浏览器地址和网址格式化打印到szCmd数组中</span></span><br><span class="line">        <span class="keyword">if</span>( !CreateProcess(<span class="literal">NULL</span>, (LPTSTR)(LPCTSTR)szCmd,</span><br><span class="line">                            <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">                            NORMAL_PRIORITY_CLASS,</span><br><span class="line">                            <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi) ) <span class="comment">//创建进程,第二个参数用于指向一个以NULL结尾的字符串，该字符串指定要执行的命令行。</span></span><br><span class="line">            <span class="keyword">break</span>;         <span class="comment">//FALSE表示新进程没有从调用进程处继承了句柄。</span></span><br><span class="line">        <span class="keyword">if</span>( pi.hProcess != <span class="literal">NULL</span> )   <span class="comment">//pi.hProcess返回新进程的句柄</span></span><br><span class="line">            CloseHandle(pi.hProcess);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>运行 → 注册表编辑器regedit.exe</p>
<p>随后进入如下路径</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%2013.png" alt="Untitled"></p>
<p>可以看到我们要找的AppInit_DLLs ,  但是我的虚拟机里没有LoadAppInit_DLLs选项,  但是其实就是一个DWORD值,  所以新建一个试试</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%2014.png" alt="Untitled"></p>
<p>同时修改其值,  如下:</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%2015.png" alt="Untitled"></p>
<p>重启电脑后,  查看ProcessExplorer</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%2016.png" alt="Untitled"></p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%2017.png" alt="Untitled"></p>
<p>发现所有加载了user32.dll的进程都加载了myhack2.dll</p>
<p>但是myhack2.dll只对notepad.exe生效,  所以我们打开notepad.exe查看效果,  由于窗口为隐藏,  只能使用ProcessExplorer查看</p>
<p><img src="/2022/04/05/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%2083e0b/Untitled%2018.png" alt="Untitled"></p>
<p>下面就是复原重启即可</p>
<p>最后的DLL再上章讲过了,  看21章内容即可</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LamのCrow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/05/逆向工程核心原理-第 83e0b/">http://example.com/2022/04/05/逆向工程核心原理-第 83e0b/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">LamのCrow</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">逆向工程核心原理</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E7%AC%AC%20cec00/"><i class="fa fa-chevron-left">  </i><span>逆向工程核心原理-24</span></a></div><div class="next-post pull-right"><a href="/2022/03/31/%E9%80%86%E5%90%91%E6%A0%B8%E5%BF%83%E5%B7%A5%E7%A8%8B%E5%8E%9F%E7%90%86-%E7%AC%AC%2055802/"><span>逆向工程核心原理-21</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By LamのCrow</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">追求幸福</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>