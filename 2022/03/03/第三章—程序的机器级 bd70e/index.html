<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="CSAPP-3"><meta name="keywords" content="CSAPP"><meta name="author" content="LamのCrow"><meta name="copyright" content="LamのCrow"><title>CSAPP-3 | LamのCrow</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.</span> <span class="toc-text">第三章—程序的机器级表示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-2-%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">3.2   程序编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">机器级代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ATT%E4%B8%8EIntel%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">ATT与Intel汇编代码格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-3-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">3.3   数据格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-4-%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">4.</span> <span class="toc-text">3.4   访问信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%A4%84%E7%90%86%E5%90%84%E7%A7%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.</span> <span class="toc-text">寄存器处理各种长度的数据的方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">操作数指示符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">4.4.</span> <span class="toc-text">数据传送指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MOV%E7%B1%BB"><span class="toc-number">4.4.1.</span> <span class="toc-text">MOV类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MOVZ-Z%E5%B0%B1%E6%98%AFzero-%E6%84%8F%E6%80%9D%E6%98%AF%E9%9B%B6%E6%89%A9%E5%B1%95-%E7%B1%BB"><span class="toc-number">4.4.2.</span> <span class="toc-text">MOVZ(Z就是zero,  意思是零扩展)类:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MOVS-S%E5%B0%B1%E6%98%AFsign-%E6%84%8F%E6%80%9D%E6%98%AF%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95-%E7%B1%BB"><span class="toc-number">4.4.3.</span> <span class="toc-text">MOVS(S就是sign,  意思是符号扩展)类:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">4.5.</span> <span class="toc-text">压入和弹出数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">算术和逻辑操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80%E2%80%94leaq-load-effective-address"><span class="toc-number">5.1.</span> <span class="toc-text">加载有效地址—leaq(load effective address)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%92%8C%E4%BA%8C%E5%85%83%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.</span> <span class="toc-text">一元和二元操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.</span> <span class="toc-text">移位操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.1.</span> <span class="toc-text">左移操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E7%A7%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.2.</span> <span class="toc-text">右移操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">5.4.</span> <span class="toc-text">特殊的算术操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">5.4.1.</span> <span class="toc-text">除法运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="toc-number">6.1.</span> <span class="toc-text">条件码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CMP-%E5%92%8C-TEST-%E6%8C%87%E4%BB%A4"><span class="toc-number">6.1.1.</span> <span class="toc-text">CMP 和 TEST 指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AT-amp-T%E9%A3%8E%E6%A0%BC%E4%B8%8EIntel%E9%A3%8E%E6%A0%BC%E7%9A%84cmp%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82-%E8%AE%B0%E5%BE%97%E4%B9%8B%E5%89%8D%E5%86%99%E8%BF%87%E7%9A%84-%E4%BD%86%E6%98%AF%E6%B2%A1%E6%89%BE%E7%9D%80-%E8%BF%99%E9%87%8C%E5%A4%9A%E5%86%99%E4%B8%80%E9%81%8D-%E5%A6%82%E6%9C%89%E9%87%8D%E5%A4%8D-%E4%B8%8D%E8%A6%81%E5%BF%BD%E7%95%A5-%E7%9C%8B%E4%B8%A4%E9%81%8D-%E7%9C%9F%E7%9A%84%E5%AE%B9%E6%98%93%E8%AE%B0%E6%B7%B7"><span class="toc-number">6.2.</span> <span class="toc-text">AT&amp;T风格与Intel风格的cmp之间的差异(记得之前写过的,  但是没找着,  这里多写一遍,  如有重复,  不要忽略,  看两遍,  真的容易记混)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AT-amp-T%E9%A3%8E%E6%A0%BC"><span class="toc-number">6.2.1.</span> <span class="toc-text">AT&amp;T风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intel%E9%A3%8E%E6%A0%BC"><span class="toc-number">6.2.2.</span> <span class="toc-text">Intel风格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="toc-number">6.3.</span> <span class="toc-text">访问条件码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95-SET"><span class="toc-number">6.3.1.</span> <span class="toc-text">第一种方法(SET)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">6.4.</span> <span class="toc-text">跳转指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">6.4.1.</span> <span class="toc-text">跳转指令的目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81"><span class="toc-number">6.5.</span> <span class="toc-text">跳转指令的编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PC%E7%9B%B8%E5%AF%B9"><span class="toc-number">6.5.1.</span> <span class="toc-text">PC相对</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="toc-number">6.6.</span> <span class="toc-text">用条件控制来实现条件分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%9D%A1%E4%BB%B6%E4%BC%A0%E9%80%81%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="toc-number">6.7.</span> <span class="toc-text">用条件传送来实现条件分支</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E4%BC%A0%E9%80%81%E6%95%88%E7%8E%87%E6%AF%94%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">6.7.1.</span> <span class="toc-text">条件传送效率比条件控制高的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%983-20"><span class="toc-number">6.7.2.</span> <span class="toc-text">练习题3 . 20</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.8.</span> <span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#do-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.8.1.</span> <span class="toc-text">do-while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.8.2.</span> <span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.8.3.</span> <span class="toc-text">for循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.9.</span> <span class="toc-text">switch语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88"><span class="toc-number">7.1.</span> <span class="toc-text">运行时栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6"><span class="toc-number">7.2.</span> <span class="toc-text">转移控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#call%E6%8C%87%E4%BB%A4-%E5%92%8C-ret%E6%8C%87%E4%BB%A4"><span class="toc-number">7.2.1.</span> <span class="toc-text">call指令 和 ret指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="toc-number">7.3.</span> <span class="toc-text">数据传送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8A%E7%9A%84%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-number">7.4.</span> <span class="toc-text">栈上的局部存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">7.5.</span> <span class="toc-text">寄存器中的局部存储空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%9D%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">7.5.1.</span> <span class="toc-text">被调用者保存寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%80%85%E4%BF%9D%E5%AD%98%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">7.5.2.</span> <span class="toc-text">调用者保存寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B"><span class="toc-number">7.6.</span> <span class="toc-text">递归过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="toc-number">8.</span> <span class="toc-text">数组分配和访问</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E8%B7%9F%E6%B1%87%E7%BC%96%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.1.</span> <span class="toc-text">C语言数组指针跟汇编的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84"><span class="toc-number">8.2.</span> <span class="toc-text">嵌套数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-number">8.3.</span> <span class="toc-text">变长数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E8%B4%A8%E7%9A%84%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE"><span class="toc-number">9.</span> <span class="toc-text">异质的结构数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88"><span class="toc-number">9.2.</span> <span class="toc-text">联合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B0%86%E6%8E%A7%E5%88%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E5%90%88%E8%B5%B7%E6%9D%A5"><span class="toc-number">10.</span> <span class="toc-text">机器级程序中将控制和数据结合起来</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">10.1.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E5%BC%95%E7%94%A8%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">10.2.</span> <span class="toc-text">内存越界引用和缓冲区溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">10.2.1.</span> <span class="toc-text">缓冲区溢出</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s4.ax1x.com/2021/12/07/oyWTJA.jpg"></div><div class="author-info__name text-center">LamのCrow</div><div class="author-info__description text-center">欢迎交流!!!</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">23</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://space.bilibili.com/202089320">MyBIlibili</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://sma11cc.github.io/">smallcc</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">LamのCrow</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">CSAPP-3</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-03</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="第三章—程序的机器级表示"><a href="#第三章—程序的机器级表示" class="headerlink" title="第三章—程序的机器级表示"></a>第三章—程序的机器级表示</h1><span id="more"></span>

<h1 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2   程序编码"></a>3.2   程序编码</h1><h2 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h2><p>这里有一些跟我平常看到不一样的名词</p>
<ul>
<li>程序计数器(之前一直都叫它ip,  就是给出指令地址的寄存器):  通常称为PC,  给出下一条指令的地址</li>
<li>条件码寄存器:  保存最近执行的算数或逻辑指令的状态信息,  实现if和while语句(汇编里的jnz, 看的就是这个)</li>
</ul>
<h2 id="ATT与Intel汇编代码格式"><a href="#ATT与Intel汇编代码格式" class="headerlink" title="ATT与Intel汇编代码格式"></a>ATT与Intel汇编代码格式</h2><ul>
<li>ATT是运营贝尔实验室的公司的汇编代码格式,  是GCC,  OBJDUMP和其他工具使用的格式                  :如:  mov     rbx,  rdx     是将rbx的值给rdx</li>
<li>Intel是我们平常看见的格式                                                                                                              :如:  mov     rbx,  rdx     是将rdx的值给rbx,  跟上面的格式是反过来的,  (两者有点像大小端)</li>
</ul>
<h1 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3   数据格式"></a>3.3   数据格式</h1><p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled.png" alt="Untitled"></p>
<p>GCC生成的汇编代码都有一个字符的后缀表明操作数的大小</p>
<ul>
<li>movb     传送字节</li>
<li>movw    传送字</li>
<li>movl     传送双字</li>
<li>movq     传送四字</li>
</ul>
<p>浮点数也有s  跟   l,  但跟整数不会产生冲突,  因为寄存器不一样,  可以根据寄存器来进行判断</p>
<h1 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4   访问信息"></a>3.4   访问信息</h1><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%201.png" alt="Untitled"></p>
<h2 id="寄存器处理各种长度的数据的方案"><a href="#寄存器处理各种长度的数据的方案" class="headerlink" title="寄存器处理各种长度的数据的方案"></a>寄存器处理各种长度的数据的方案</h2><ul>
<li>1字节&amp;2字节:  保持剩下的字节数不变</li>
<li>四字节:  会把高四位的四个字节置为 0</li>
</ul>
<h2 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h2><p>大多数指令都有一个或者多个操作数(注意是大多数,  也就是说存在没有操作数的指令)</p>
<p>操作数分为三种类型:</p>
<ul>
<li>立即数:  (在ATT格式汇编中)书写方式是 ’ $ ’ 后跟常数值,  如:  $ -577    和    $ 0x1F</li>
<li>寄存器:  表示每个寄存器的内容,  一个寄存器也分为1字节,  2字节,  4字节,  8字节                               .其中r来表示任意寄存器,   R[r]  来表示r寄存器的值</li>
<li>内存引用:  Addr表示地址,  M[Addr]表示对存储在内存中从Addr开始的引用</li>
</ul>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%202.png" alt="Untitled"></p>
<p>上面的这张图还是背下来比较好,  还有注意图下的话,  比例因子s必须是1, 2, 4 和 8</p>
<p>记住上面的要领就是,  只有$  和  RXX(寄存器)  这两个表示的是直接数,  其他都表示的是地址(当然,  也要看具体的指令,  比如lea)</p>
<h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><h3 id="MOV类"><a href="#MOV类" class="headerlink" title="MOV类"></a>MOV类</h3><p>主要讲的是MOV类,  分为以下类:</p>
<ol>
<li>movb     传送1字节数据(字节)</li>
<li>movw     传送2字节数据(字)</li>
<li>movl     传送4字节数据(双字),  其他赋值给寄存器的mov都不会改变寄存器其他的位,  但是movl会把寄存器高位的4字节设置为0</li>
<li>movq     传送8字节数据(四字)</li>
</ol>
<ul>
<li>重点:   mov指令的两个操作数不能都指向内存位置(之前汇编语言也讲过,  我觉得这个真的很重要)          所以我们要将一个内存a的值写入内存b中,  要先将a中的值给寄存器,  然后寄存器再将值写入内存b中</li>
</ul>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%203.png" alt="Untitled"></p>
<p>movabsq传送绝对的四字就是传送的值一定是长度位64位.</p>
<p>这里讲一下mavq和movabs的区别:</p>
<ul>
<li>如果源操作数是立即数的话没有区别</li>
<li>64位编译下,  源操作数如果是标号,  默写情况下只能用movabs进行64位立即数的赋值而无法使用movq</li>
</ul>
<h3 id="MOVZ-Z就是zero-意思是零扩展-类"><a href="#MOVZ-Z就是zero-意思是零扩展-类" class="headerlink" title="MOVZ(Z就是zero,  意思是零扩展)类:"></a>MOVZ(Z就是zero,  意思是零扩展)类:</h3><ul>
<li>movzbw     b → w  将做了零扩展的字节传送到字</li>
<li>movzbl     b → l  将做了零扩展的字节传送到双字</li>
<li>movzwl     w → l  将做了零扩展的字传送到双字</li>
<li>movzbq     b → q  将做了零扩展的字节传送到四字</li>
<li>movzwq     w → q  将做了零扩展的字传送到四字</li>
</ul>
<p>注意零扩展是用零填充到目的操作数的长度,  其次源操作数的长度必须小于目的操作数(要不然也没意义)</p>
<h3 id="MOVS-S就是sign-意思是符号扩展-类"><a href="#MOVS-S就是sign-意思是符号扩展-类" class="headerlink" title="MOVS(S就是sign,  意思是符号扩展)类:"></a>MOVS(S就是sign,  意思是符号扩展)类:</h3><ul>
<li>movsbw     b → w  将做了零扩展的字节传送到字</li>
<li>movsbl     b → l  将做了零扩展的字节传送到双字</li>
<li>movswl     w → l  将做了零扩展的字传送到双字</li>
<li>movsbq     b → q  将做了零扩展的字节传送到四字</li>
<li>movswq     w → q  将做了零扩展的字传送到四字</li>
<li>movslq     l → q 将做了符号扩展的双字传送到四字(注意上面是没有这一条的,  因为原本l到q就会做高四字节的零填充)</li>
<li>cltq     符号扩展(%eax) → %rax   把%eax符号扩展到%rax,   相当于movslq   %eax, %rax</li>
</ul>
<p>注意:  符号扩展的符号看源操作数,  扩展的范围看目的操作数.</p>
<h2 id="压入和弹出数据"><a href="#压入和弹出数据" class="headerlink" title="压入和弹出数据"></a>压入和弹出数据</h2><p>栈是一种数据结构,  遵循”后进先出”的原则,  在过程调用中起到至关重要的作用.</p>
<p>压入和弹出的具体过程:</p>
<p>压入:</p>
<ul>
<li>栈顶指针向低地址移动</li>
<li>将数据压入栈中</li>
</ul>
<p>弹出:</p>
<ul>
<li>将数据弹出</li>
<li>栈顶指针向高地址移动</li>
</ul>
<p>可以看到上面压入和弹出的顺序是相反的,  其实把这个过程想成一个桶,  你要先腾出空间才能放进东西,  同理,  你也要先把东西拿出来,  才能压缩空间(这样记会好记一些).</p>
<h1 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h1><p>大多数操作都分成了指令类,  指令类又不同大小操作数的变种(leaq除外仅此一个):</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%204.png" alt="Untitled"></p>
<p>注意看操作数运算的顺序,  然后学个新词(arithmetic    算术)</p>
<h2 id="加载有效地址—leaq-load-effective-address"><a href="#加载有效地址—leaq-load-effective-address" class="headerlink" title="加载有效地址—leaq(load effective address)"></a>加载有效地址—leaq(load effective address)</h2><p>功能有两个:</p>
<ul>
<li>将有效的内存地址传给目的操作数</li>
<li>进行简介的算术操作,  比如:   leaq   7(%rdx,  %rdx,  4), %rax,  设 rdx 为 x 就是5x + 7</li>
</ul>
<h2 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h2><p>一元操作是只有一个操作数(既是源也是目的),  比如:  inc(加一),  dec(减一)</p>
<p>二元操作是有两个操作数,  其中第三组的第二个操作数既是源也是目的,  不过要记住源操作数是第一个,  目的操作数是第二个(这段话来自书中,  说实话有点看不懂,  但是我觉得知道第三组各个指令的用法和含义就好了,  在这里不用深究)</p>
<h2 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h2><h3 id="左移操作"><a href="#左移操作" class="headerlink" title="左移操作"></a>左移操作</h3><p>又SAL 和 SHL,  二者作用一样,  因为左移不用考虑符号的问题,  全部补零即可</p>
<h3 id="右移操作"><a href="#右移操作" class="headerlink" title="右移操作"></a>右移操作</h3><ul>
<li>SAR(arithmetic)算术右移,  适用补码,  根据最高符号位决定填充为 0 还是 1</li>
<li>SHR(逻辑不是logic吗)逻辑右移,  适应无符号类型,  填充始终为 0</li>
</ul>
<h2 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h2><p>两个64位整数相乘得到的乘积需要128位(两个64位寄存器)来表示,  将其称为16个字节的八字(oct word)</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%205.png" alt="Untitled"></p>
<p>多出来的部分就用RDX来表示</p>
<p>操作数可以是两个也可以是一个,  一个时,  那个操作数就是源操作数,  而目的操作数则在%RAX中</p>
<p>虽然用的时同一个指令,  但汇编器能够通过操作数个数来判断你想要表达什么.</p>
<h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><ul>
<li>对于128位除法运算(idivl),  高64位放在RDX,  低64位放在RAX,  然后使用idivl  num,                             相当于  RDXRAX /  num     ,    商会存储在RAX中,  余数则存储在RDX中</li>
<li>对于64位除法运算(idivq),  被除数放在RAX中,  然后使用idivq   num,  相当于RAX  /   num                   商存储在RAX中,  余数存储在RDX中</li>
<li>注意使用前要先使用cqto(ATT格式)或者cqo(intel格式)将rdx的位设为0(无符号)或rax的符号位(补码)</li>
</ul>
<p>还是用书中的实例更清晰一些</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%206.png" alt="Untitled"></p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%207.png" alt="Untitled"></p>
<h1 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h1><p>直线代码:  就是指令一条接着一条顺序执行.  </p>
<p>但是条件语句,  循环语句,  分支语句,  要根据测试结果来决定程序操作执行的顺序,  这时我们就需要机器代码提供的两种基本的低级机制来实现有条件的行为,  也就是:  测试数据值,  然后根据测试的结果来改变控制流或者数据流.    一个就是jump.</p>
<h2 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h2><p>条件码(condition code)寄存器:  描述了最近的算术或逻辑操作的属性,  可以通过条件码的值来执行条件分支指令.</p>
<p>常见的条件码:</p>
<ul>
<li>CF (carry flag):  进位标志,  最近的操作使最高位产生进位,  可用于检查无符号操作的溢出</li>
<li>ZF (zero flag):  零标志,  最近的操作得出的结果为0,  则flag为 1 .</li>
<li>SF (sign flag):  符号标志,  最近的操作得到的结果为负数,  则flag为 1 .</li>
<li>OF  (over flag):  溢出标志,  最近的操作导致一个补码溢出——正溢出或负溢出.</li>
</ul>
<p>leaq不改变条件码,  因为它是用来进行地址运算的</p>
<p>一些规则:</p>
<ul>
<li>对于逻辑操作,  如 xor ,  进位和溢出标志都会设置为 0 ,  因为逻辑操作不可能进位或者溢出</li>
<li>对于移位操作,  进位标志将设置为最后一个被移出的位,  而溢出标志设置为 0 .</li>
<li>INC 和 DEC 指令会设置溢出和零标志,  但不会改变进位标志,  原因不深入讨论.</li>
</ul>
<h3 id="CMP-和-TEST-指令"><a href="#CMP-和-TEST-指令" class="headerlink" title="CMP 和 TEST 指令"></a>CMP 和 TEST 指令</h3><p>只设置条件码寄存器,  而不改变其他寄存器的值</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%208.png" alt="Untitled"></p>
<h2 id="AT-amp-T风格与Intel风格的cmp之间的差异-记得之前写过的-但是没找着-这里多写一遍-如有重复-不要忽略-看两遍-真的容易记混"><a href="#AT-amp-T风格与Intel风格的cmp之间的差异-记得之前写过的-但是没找着-这里多写一遍-如有重复-不要忽略-看两遍-真的容易记混" class="headerlink" title="AT&amp;T风格与Intel风格的cmp之间的差异(记得之前写过的,  但是没找着,  这里多写一遍,  如有重复,  不要忽略,  看两遍,  真的容易记混)"></a>AT&amp;T风格与Intel风格的cmp之间的差异(记得之前写过的,  但是没找着,  这里多写一遍,  如有重复,  不要忽略,  看两遍,  真的容易记混)</h2><h3 id="AT-amp-T风格"><a href="#AT-amp-T风格" class="headerlink" title="AT&amp;T风格"></a>AT&amp;T风格</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmp    %eax,  %ebx</span><br><span class="line">jg &lt; something &gt;</span><br><span class="line">相当于如果ebx &gt; eax,  则跳转</span><br><span class="line">比较eax跟ebx的位置互换,  然后再比较取得符号</span><br></pre></td></tr></table></figure>

<h3 id="Intel风格"><a href="#Intel风格" class="headerlink" title="Intel风格"></a>Intel风格</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmp     %eax,  %ebx</span><br><span class="line">jg &lt; something &gt;</span><br><span class="line">相当于如果eax &gt; ebx,  则跳转</span><br><span class="line">比较eax跟ebx的位置不用互换,  直接在中间比较就行了</span><br></pre></td></tr></table></figure>

<h2 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h2><p>使用方法有三种:</p>
<ul>
<li>可以根据条件码的组合,  将一个字节(可以是寄存器的字节形式 ( 如al ) ,  也可以是字节内存)设为0 或者1</li>
<li>可以条件跳转到程序的某个其他的部分</li>
<li>可以有条件的传送数据</li>
</ul>
<h3 id="第一种方法-SET"><a href="#第一种方法-SET" class="headerlink" title="第一种方法(SET)"></a>第一种方法(SET)</h3><p>将一个字节设置为 0 或者 1 ,  我们将这类指令称为SET指令;  这些指令名字的不同后缀指明了它们所需要考虑的条件码的组合(而不代表大小).如:</p>
<ul>
<li>setl:  表示小于时设置( set less ),  而不是设置长字( set long word )</li>
<li>setb:  表示低于时设置( set below ),  而不是设置字节( set byte )</li>
</ul>
<p>这里重复上面的话:  SET一个字节(可以是寄存器的字节形式 ( 如al ) ,  也可以是字节内存)设为0 或者1但是有时我们会想要得到的是一个32位或者是64位的结果(也许是因为我们的变量设置为int),  我们必须对高位清零.</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%209.png" alt="Untitled"></p>
<p>注意:  </p>
<p>ATT的cmp指令是后面的减前面的,  所以小于表示的是,  第二个操作数小于第一个操作数</p>
<p>而Intel的cmp指令是前面的减后面的,  所以小于表示的是,  第一个操作数小于第二个操作数</p>
<p>不得不提CSAPP的ATT跟Intel风格的差异真的让人头晕,  看到这里真的麻了………</p>
<h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><p>正常执行下,  指令是按照出现顺序一条一条的执行,  但是跳转指令( jmp )会导致执行切换到程序中一个全新的位置.  这些跳转的目的地通常用一个标号( label )指明.  </p>
<h3 id="跳转指令的目标"><a href="#跳转指令的目标" class="headerlink" title="跳转指令的目标"></a>跳转指令的目标</h3><p>目标有三种类型:</p>
<ul>
<li>直接跳转,  标号作为跳转的目标,  如:  jmp     .1L</li>
<li>间接跳转,  寄存器中的值作为跳转目标,  如:  jmp     *%rax,  *  为操作数指示符</li>
<li>间接跳转,  内存中的值作为跳转目标,  如:  jmp     *(%rax),  用寄存器rax中的值作为地址,  从内存中读出跳转目标</li>
</ul>
<p>跳转类型又分为两种:</p>
<ul>
<li>jmp,  无条件跳转</li>
<li>jnz等,  有条件跳转</li>
</ul>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2010.png" alt="Untitled"></p>
<p>这里有一个记忆方法(比较捞):  带ab的是无符号的,  gl是有符号的,  e是不知道(只用记住ab就好了,  其他的可以排除法)</p>
<h2 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h2><p>汇编代码中,  跳转目标使用符号和标号书写,  汇编器,  以及链接器会产生跳转目标的编码,  主要的编码方式有两种:</p>
<ul>
<li>最常用的是PC相对(PC-relative),  是将目标指令的地址与紧跟在跳转指令后的那条指令的地址之间的差作为编码.</li>
<li>第二种是给出”绝对”地址,  用四个字节直接指定目标</li>
</ul>
<h3 id="PC相对"><a href="#PC相对" class="headerlink" title="PC相对"></a>PC相对</h3><p>看一下书中的例子</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2011.png" alt="Untitled"></p>
<p>这样的编码方式可以保证指令编码的简介(只用两个字节,  如果用绝对地址就需要更长的编码了)</p>
<h2 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h2><p>常见的有cmp还有test跟jmp,  jnz系列的组合来构成条件分支</p>
<p>看看书中的实例比较清晰</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2012.png" alt="Untitled"></p>
<h2 id="用条件传送来实现条件分支"><a href="#用条件传送来实现条件分支" class="headerlink" title="用条件传送来实现条件分支"></a>用条件传送来实现条件分支</h2><p>先将两种情况的结果计算出来,  再根据判断决定谁是最终的结果</p>
<p>与条件控制不同的地方在于:</p>
<ul>
<li>预先计算出了两个结果,  再判断</li>
<li>使用的是传送指令,  且传送指令受判断决定是否执行</li>
</ul>
<p>在这里我还要再说一下第二个不同之处,  条件控制就像是一个空的盒子,  你判断后再决定放书还是放零食,  条件传送是原本装了零食了,  然后你判断是保持放零食不变,  还是把零食换成书</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2013.png" alt="Untitled"></p>
<h3 id="条件传送效率比条件控制高的原因"><a href="#条件传送效率比条件控制高的原因" class="headerlink" title="条件传送效率比条件控制高的原因"></a>条件传送效率比条件控制高的原因</h3><p>处理器通过使用流水线( pipelining )来获得高性能,  这里用自己的话来讲更容易一些:  就是处理器会预先处理前面的指令,  所以如果条件预判错误的话,  会损失性能.  然而条件传送则受到的影响很小.</p>
<p>下面是条件传送的种类:</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2014.png" alt="Untitled"></p>
<p>后缀变成了条件,  而关于数据长度则通过寄存器的类别判断</p>
<p>但是必须要注意,  条件传送的弊端:</p>
<ul>
<li>两个结果的其中一个可能导致程序错误,  如果使用条件传送提前执行的话,  程序将无法运行</li>
<li>如果两个结果的运算过程都很复杂,  使提前计算所耗费的性能超过了条件控制的惩罚那就得不偿失了</li>
</ul>
<p>所以虽然条件传送更符合现代处理器的运行方式,  但是它只能运行在非常受限的情况.</p>
<h3 id="练习题3-20"><a href="#练习题3-20" class="headerlink" title="练习题3 . 20"></a>练习题3 . 20</h3><p>这道题学到了关于除法和右移之间的关系</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2015.png" alt="Untitled"></p>
<p>一开始的除法运算时猜的.</p>
<p>主要的疑问在于为什么要加上 7</p>
<p>这当公式被就行了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果负数要右移k位,  那么用被除数的补码加上<span class="number">2</span> ^ k - <span class="number">1</span>(注意, ^表示的是次方的意思)</span><br><span class="line"></span><br><span class="line">比如-<span class="number">1</span>的补码是<span class="number">0xf</span>  补码算术右移之后还是<span class="number">0xf</span></span><br><span class="line">但是加上了(<span class="number">2</span>的一次方 - <span class="number">1</span>)就是<span class="number">0</span> &gt;&gt; <span class="number">1</span>  就是正确的<span class="number">0</span>了</span><br><span class="line"></span><br><span class="line">再比如-<span class="number">3</span>的补码是<span class="number">0xD</span>(<span class="number">1101</span>) + <span class="number">1</span> == <span class="number">0xE</span> (<span class="number">1110</span>),  再右移就是-<span class="number">1</span>了</span><br><span class="line"></span><br><span class="line">最后要尽量避免除法,  一个除法要消耗几百个始终,  是对性能的极大浪费,  所以能用右移尽量用右移  </span><br></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>do-while,  while 和 for再汇编中是通过条件测试和跳转组合起来实现循环的效果</p>
<h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h3><p>模板</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">		body-satement</span><br><span class="line">		t = test-expr;</span><br><span class="line">		<span class="keyword">if</span> (t)</span><br><span class="line">				<span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>

<p>用书中的实例说明</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2016.png" alt="Untitled"></p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>实现while循环共有两种方法</p>
<ul>
<li>方法一(跳到中间(jump to middle)):  使用一个无条件跳转,  直接跳转到检查条件处</li>
</ul>
<p>模板</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">		goto test;</span><br><span class="line">loop:</span><br><span class="line">		body-statement</span><br><span class="line">test:</span><br><span class="line">		t = test-expr;</span><br><span class="line">		<span class="keyword">if</span> (t)</span><br><span class="line">				goto loop;</span><br></pre></td></tr></table></figure>

<p>书中实例:</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2017.png" alt="Untitled"></p>
<ul>
<li>方法二(guarded-do): 再循环前先使用条件分支,  不成立则跳过循环,  等于加上了单次的检查</li>
</ul>
<p>模板:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">loop:</span><br><span class="line">		body-statement</span><br><span class="line">		t = test-expr;</span><br><span class="line">		<span class="keyword">if</span> (t)</span><br><span class="line">				<span class="keyword">goto</span> loop;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>

<p>书中实例:</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2018.png" alt="Untitled"></p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2019.png" alt="Untitled"></p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环一般形式为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (init-expr;  test-expr;  update-expr)</span><br><span class="line">		body-statement</span><br></pre></td></tr></table></figure>

<p>转换成while:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init0expr;</span><br><span class="line"><span class="keyword">while</span> (test-expr)</span><br><span class="line">&#123;</span><br><span class="line">		body-statement</span><br><span class="line">		update-expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以可以使用两个表示while的方式(jump to middle 和 guarded-do)来表示for循环</p>
<ul>
<li>jump to middle方法表示for循环</li>
</ul>
<p>模板</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">		init-expr;</span><br><span class="line">		<span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">		body-statement</span><br><span class="line">		update-expr;</span><br><span class="line">test:</span><br><span class="line">		t = test-expr;</span><br><span class="line">		<span class="keyword">if</span> (t)</span><br><span class="line">				<span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>

<ul>
<li>guarded-do方法表示for循环</li>
</ul>
<p>模板</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">		init-expr;</span><br><span class="line">		t = test-expr;</span><br><span class="line">		<span class="keyword">if</span> (!t)</span><br><span class="line">				<span class="keyword">goto</span> done;</span><br><span class="line">loop:</span><br><span class="line">		body-statement</span><br><span class="line">		update-expr;</span><br><span class="line">		t = test-expr;</span><br><span class="line">		<span class="keyword">if</span> (t)</span><br><span class="line">				<span class="keyword">goto</span> loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>通过跳转表(jump table)这种数据结果来实现更加高效的表现.</p>
<p>通过实例</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2020.png" alt="Untitled"></p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2021.png" alt="Untitled"></p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>过程(函数就是其中一种)是软件中一种很重要的抽象.  提供了一种分装代码的方式,  用一组指定的参数和可选的返回值实现了某种功能.  然后,  可以在程序中不同的地方Dion公用这个过程.</p>
<p>形式多样:</p>
<ul>
<li>函数(function)</li>
<li>方法(method)</li>
<li>子例程(subroutine)</li>
<li>处理函数(handler)</li>
</ul>
<p>其中的调用机制(假设P调用了Q)</p>
<ul>
<li>传递控制,  进入过程Q是,  程序计数器(rip)必须是Q代码的起始地址,  返回时程序计数器又必须是P调用Q的那条指令后面的地址</li>
<li>传递数据,  P能向Q传递一个或多个参数,  Q能向P返回一个值</li>
<li>分配和释放内存,  开始时给Q分配内存空间,  结束时释放内存空间</li>
</ul>
<h2 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h2><p>主要的图</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2022.png" alt="Untitled"></p>
<h2 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h2><p>将控制从P转移到Q,  只用把程序计数器设置成Q的代码,  但是返回时需要P下条指令的代码,  这就需要我们的转移控制机制了(将P下条指令的地址保存备用)</p>
<h3 id="call指令-和-ret指令"><a href="#call指令-和-ret指令" class="headerlink" title="call指令 和 ret指令"></a>call指令 和 ret指令</h3><p>call包括了两个部分:  一个是将程序计数器置为Q,  另一个是将返回地址压入栈中</p>
<p>ret则相反:  是弹出返回地址到程序计数器,  控制回到了P  </p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2023.png" alt="Untitled"></p>
<h2 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h2><p>跟之前学的汇编语言(王爽老师的,  有点过时了)不一样(参数都是压入栈中),  x86-64调用中的数据传送都是通过寄存器传递,  在大于6个参数的时候,  会把多出来的参数压入栈中</p>
<p>栈中的参数分配的空间也有规则:  数据大小要向 8 的倍数对齐</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2024.png" alt="Untitled"></p>
<p>上面的那个对齐规则我不是很懂,  这个8 的倍数是8个位还是8个字节,  但是从书中的实例来看,  看&lt;栈上的局部存储&gt;的第二个实例,  rsp也有加一的,  所以应该是8个位吧………</p>
<p>书中实例:</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2025.png" alt="Untitled"></p>
<h2 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h2><p>虽然寄存器很多时候都能够完成很多局部变量的存储和运算,  但是有些时候还是要用到栈</p>
<p>这些情况包括:</p>
<ul>
<li>寄存器不够存放所有的本地数据</li>
<li>对一个局部变量使用地址运算符” &amp; ” ,  因此必须为它生成一个内存地址</li>
<li>某些局部变量是数组或是结构,  因此必须能够通过数组或结果引用被访问到</li>
</ul>
<p>书中实例:</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2026.png" alt="Untitled"></p>
<p>这个实例时较复杂的那个</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2027.png" alt="Untitled"></p>
<h2 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h2><h3 id="被调用者保存寄存器"><a href="#被调用者保存寄存器" class="headerlink" title="被调用者保存寄存器"></a>被调用者保存寄存器</h3><p>根据惯例,  RBX 和 RBP 和 R12 ~ R15被划分为被调用者保存寄存器:  当P调用Q时,  被调用者Q必须保存这些寄存器的值,  保证它们的值在Q返回到P时,  与调用Q前一样.</p>
<p>保存方法有两种:</p>
<ul>
<li>不改变这个寄存器的值</li>
<li>将寄存器的值压入栈中</li>
</ul>
<h3 id="调用者保存寄存器"><a href="#调用者保存寄存器" class="headerlink" title="调用者保存寄存器"></a>调用者保存寄存器</h3><p>除了RSP 和 被调用者保存寄存器,  其他的寄存器都归为调用者保存寄存器.</p>
<p>调用者保存可以这样理解:  P调用Q,  Q可以随意修改这些寄存器, 所以在调用前预先保存好这些数据时P(调用者)的责任</p>
<p>书中实例:</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2028.png" alt="Untitled"></p>
<p>我认为这里的被调用者保存寄存器,  是因为在调用Q的时候不会改变才使用的,  上面的两个push并没有体现被调用者保存寄存器的特性, 只是在P的函数中防止rbp跟rbx之前的值被覆盖……这样讲的很晕</p>
<h2 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h2><p>书中实例也使用了被调用着保存寄存器 以及 栈的特性</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2029.png" alt="Untitled"></p>
<h1 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h1><p>数组再内存中的存放看的时数组元素的类型</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2030.png" alt="Untitled"></p>
<h2 id="C语言数组指针跟汇编的关系"><a href="#C语言数组指针跟汇编的关系" class="headerlink" title="C语言数组指针跟汇编的关系"></a>C语言数组指针跟汇编的关系</h2><p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2031.png" alt="Untitled"></p>
<h2 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h2><p>遵循 ”行优先” 原则</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2032.png" alt="Untitled"></p>
<h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>形式形如:  int A [expr1] [expr2]</p>
<p>这样的表达式来指定任意元素,  但是在使用前,  expr1跟expr2必须先计算得出</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2033.png" alt="Untitled"></p>
<h1 id="异质的结构数据"><a href="#异质的结构数据" class="headerlink" title="异质的结构数据"></a>异质的结构数据</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>将不同类型的对象聚合到一个对象中,  类似于数组的实现,  结构的所有部分都存放在一段连续的内存</p>
<p>注意:</p>
<ul>
<li>传递参数时,  一般传递的时结构体的地址,  而不是每一个元素,  这样太麻烦了,  地址可以直接索引</li>
</ul>
<p>结构体内存实例:</p>
<p><img src="/2022/03/03/%E7%AC%AC%E4%B8%89%E7%AB%A0%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%20bd70e/Untitled%2034.png" alt="Untitled"></p>
<h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><h1 id="机器级程序中将控制和数据结合起来"><a href="#机器级程序中将控制和数据结合起来" class="headerlink" title="机器级程序中将控制和数据结合起来"></a>机器级程序中将控制和数据结合起来</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>关键的原则:</p>
<ul>
<li>每个指针都对应一个类型</li>
<li>指针用 “ &amp; ” 创建</li>
<li>“ * ” 用于间接引用指针</li>
<li>数组与指针联系紧密</li>
<li>将指针从一种类型强制转换成另一种类型,  只改变它的类型,  而不改变它的值</li>
<li>指针也可以指向函数</li>
</ul>
<h2 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h2><p>C对数组引用不进行任何边界检查,  而局部变量和状态信息(返回值,  寄存器原来的值)都存在栈中,  当我们输入一些数据超出了原先在栈中计划的空间时,  这些数据就会覆盖(称为破坏更合适一些)我们的重要数据.  但我们需要返回等操作时,  就会发生错误</p>
<h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>通过输入一个字符串,  字符串中包含一些可执行代码的字节编码,  称为攻击代码,  或者是一个指向攻击代码的地址.</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LamのCrow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/03/03/第三章—程序的机器级 bd70e/">http://example.com/2022/03/03/第三章—程序的机器级 bd70e/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">LamのCrow</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CSAPP/">CSAPP</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/03/03/BombLab%20ce420/"><i class="fa fa-chevron-left">  </i><span>CSAPP-Bomblab</span></a></div><div class="next-post pull-right"><a href="/2021/12/18/ReMain-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20Process%20Explorer%201d4a13b9114d452f98bdaf3760a9778b/"><span>逆向核心工程原理-9</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s4.ax1x.com/2021/12/06/oy2VdH.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By LamのCrow</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">追求幸福</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>